<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>GainGrid Hosted — Tasks & Ads (iframe-ready)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

<!-- EXACT Google AdSense core script -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2309008538670900"
     crossorigin="anonymous"></script>

<style>
  :root{--accent1:#ff6b9d;--accent2:#c471ed;--bg:linear-gradient(135deg,#0f1419 0,#1a2332 50%,#0d1117 100%);}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;color:#fff;background:var(--bg);display:flex;align-items:center;justify-content:center}
  .card{width:100%;max-width:820px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:18px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .back-btn{background:transparent;border:0;color:rgba(255,255,255,0.8);cursor:pointer;font-weight:600}
  h2{margin:0;font-size:20px}
  .small{font-size:13px;color:rgba(255,255,255,0.75)}
  .btn{padding:10px 12px;border-radius:8px;background:linear-gradient(45deg,var(--accent1),var(--accent2));border:none;color:#fff;cursor:pointer;font-weight:700}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .grid-same{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:10px;margin-top:12px}
  .card-item{padding:12px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;justify-content:space-between;align-items:center}
  .ad-player{width:100%;height:260px;border-radius:8px;overflow:hidden;background:#000;display:flex;align-items:center;justify-content:center}
  .ad-player iframe,.ad-player video{width:100%;height:100%;border:0}
  .note{margin-top:8px;color:rgba(255,255,255,0.6);font-size:13px}
  .countdown{font-weight:700;font-size:20px;color:#fff}
  .hidden{display:none}
  /* debug badge */
  #hostedDbg{position:fixed;right:10px;bottom:10px;z-index:9999;padding:6px 8px;background:rgba(0,0,0,0.6);color:#fff;font-size:12px;border-radius:6px;pointer-events:none}
  .task-list{display:flex;flex-direction:column;gap:10px;margin-top:12px;max-height:360px;overflow:auto;padding-right:8px}
</style>
</head>
<body>
  <div class="card" id="root">
    <div class="topbar">
      <button id="backBtn" class="back-btn">← Back</button>
      <h2 id="hostTitle">Hosted view</h2>
      <div class="small" id="vipInfo">VIP: —</div>
    </div>

    <div id="main" class="small">Initializing…</div>
  </div>

  <div id="hostedDbg">hosted:init</div>

<script>
/* Hosted iframe — integrated final file
   - Preserves all original names/logic/UI
   - Adds readiness handshake + PARENT_TASKS support + robust handling
*/

/* ===== CONFIG & endpoints ===== */
const ADS_LIMIT = 20;
const ADS_DURATION = 40; // seconds (fallback)
const ADS_COOLDOWN_MS = 2 * 60 * 1000;
const ADS_BASE_MIN = 60, ADS_BASE_MAX = 120;
const TASKS_LIMIT = 7;
const TASK_BASE_MIN = 100, TASK_BASE_MAX = 300;
const VIP_BONUS = { basic:20, silver:40, gold:60, premium:100 };

const ADSTER_SCRIPT_KEY = 'a8702b8b4c48420a3815542007f1c0df';
const ADSTER_SCRIPT_SRC = "//www.highperformanceformat.com/" + ADSTER_SCRIPT_KEY + "/invoke.js";
const ADSTERRA_ZONE_URL = "https://adsterra.com/video-ad/?zone=REPLACE_WITH_YOUR_ZONE";
const GOOGLE_FALLBACK_VIDEO = "https://storage.googleapis.com/interactive-media-ads/media/big_buck_bunny_trailer.mp4";

const TASK_APIS = [
  "https://jsonplaceholder.typicode.com/posts?_limit=7",
  "https://dummyjson.com/products?limit=7",
  "https://api.publicapis.org/entries",
  "https://fakestoreapi.com/products?limit=7"
];

/* ===== storage keys & helpers ===== */
const KEY_DAY = 'gg_hosted_day';
const KEY_WATCHED = 'gg_hosted_watched_ads';
const KEY_TASKS = 'gg_hosted_tasks_done';
const KEY_LAST_AD = 'gg_hosted_last_ad';
const KEY_ADS_DATA = 'ads_data';
const KEY_ADS_DATE = 'ads_date';

function nowDay(){ return new Date().toISOString().slice(0,10); }
function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function el(id){ return document.getElementById(id); }
function setMain(html){ if(el('main')) el('main').innerHTML = html; }
function escapeHtml(s){ if(!s && s !== 0) return ''; return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

(function ensureDayReset(){ const d = localStorage.getItem(KEY_DAY); if(d !== nowDay()){ localStorage.setItem(KEY_DAY, nowDay()); localStorage.removeItem(KEY_WATCHED); localStorage.removeItem(KEY_TASKS); localStorage.removeItem(KEY_LAST_AD); localStorage.removeItem(KEY_ADS_DATA); localStorage.removeItem(KEY_ADS_DATE); } })();

function getWatched(){ try{ return JSON.parse(localStorage.getItem(KEY_WATCHED)||'[]'); }catch(e){ return []; } }
function addWatched(id){ const a = getWatched(); if(!a.includes(id)){ a.push(id); localStorage.setItem(KEY_WATCHED, JSON.stringify(a)); } }
function getTasksDone(){ try{ return JSON.parse(localStorage.getItem(KEY_TASKS)||'[]'); }catch(e){ return []; } }
function addTaskDone(id){ const a = getTasksDone(); if(!a.includes(id)){ a.push(id); localStorage.setItem(KEY_TASKS, JSON.stringify(a)); } }
function setLastAdTs(ts){ localStorage.setItem(KEY_LAST_AD, String(ts)); }
function getLastAdTs(){ return Number(localStorage.getItem(KEY_LAST_AD) || 0); }
function canOpenAdNow(){ const last = getLastAdTs(); if(!last) return true; return (Date.now() - last) >= ADS_COOLDOWN_MS; }

/* ===== profile / vip resolution ===== */
let profile = null;
function readLocalProfile(){
  const keys = ['user_data','gg_user','profile','user'];
  for(const k of keys){
    try{
      const raw = localStorage.getItem(k);
      if(!raw) continue;
      const obj = JSON.parse(raw);
      if(obj && typeof obj === 'object') return obj;
    }catch(e){}
  }
  return null;
}
function postParent(msg){ try{ window.parent.postMessage(msg, '*'); }catch(e){ try{ window.opener.postMessage(msg,'*'); }catch(e){} console.warn('postParent failed', e); } }
function requestProfileFromParent(timeout=2200){
  return new Promise((resolve)=>{
    let done=false;
    function onMsg(ev){
      try{
        const d = ev.data || {};
        if(d && d.type === 'profile_response' && d.payload){ done=true; profile = d.payload; window.removeEventListener('message', onMsg); resolve(d.payload); }
      }catch(e){}
    }
    window.addEventListener('message', onMsg);
    postParent({ type:'profile_request' });
    setTimeout(()=>{ if(!done){ window.removeEventListener('message', onMsg); resolve(null); } }, timeout);
  });
}
function vipFrom(qp){ qp = qp || {}; if(qp.vip || qp.vip_level) return (qp.vip||qp.vip_level).toString(); if(profile && profile.vip_level) return profile.vip_level.toString(); const local = readLocalProfile(); if(local && local.vip_level) return local.vip_level; return 'None'; }

/* ===== reward calcs ===== */
function calcAdReward(vip){ const base = rand(ADS_BASE_MIN, ADS_BASE_MAX); const bonus = VIP_BONUS[(vip||'').toString().toLowerCase()] || 0; return { base, vip_bonus: bonus, total: base + bonus }; }
function calcTaskReward(vip){ const base = rand(TASK_BASE_MIN, TASK_BASE_MAX); const bonus = VIP_BONUS[(vip||'').toString().toLowerCase()] || 0; return { base, vip_bonus: bonus, total: base + bonus }; }

/* ===== provider helpers (ad) ===== */
function tryLoadAdsterra(zoneUrl, timeoutMs=3500){
  return new Promise((resolve) => {
    if(!zoneUrl || zoneUrl.includes('REPLACE_WITH_YOUR_ZONE')) return resolve({ ok:false });
    const iframe = document.createElement('iframe');
    iframe.src = zoneUrl;
    iframe.width = '100%'; iframe.height = '260'; iframe.style.border='0';
    let done=false;
    iframe.addEventListener('load', ()=>{ if(!done){ done=true; resolve({ ok:true, type:'adsterra', node:iframe }); }});
    iframe.addEventListener('error', ()=>{ if(!done){ done=true; resolve({ ok:false }); }});
    setTimeout(()=>{ if(!done){ done=true; resolve({ ok:false }); } }, timeoutMs);
  });
}
function tryLoadVideoSrc(videoUrl, timeoutMs=3000){
  return new Promise((resolve)=>{
    if(!videoUrl) return resolve({ ok:false });
    const video = document.createElement('video');
    video.src = videoUrl; video.controls=false; video.autoplay=true; video.muted=true; video.playsInline=true;
    let ok=false;
    function cleanup(){ video.oncanplay=null; video.onerror=null; try{ video.pause(); }catch(e){} }
    video.oncanplay = ()=>{ if(!ok){ ok=true; cleanup(); resolve({ ok:true, type:'video', node:video }); } };
    video.onerror = ()=>{ if(!ok){ ok=true; cleanup(); resolve({ ok:false }); } };
    setTimeout(()=>{ if(!ok){ ok=true; cleanup(); resolve({ ok:false }); } }, timeoutMs);
  });
}

/* ===== task aggregator ===== */
async function fetchTasks(limit = TASKS_LIMIT, timeoutPer = 3000){
  const results = [];
  for(const api of TASK_APIS){
    try{
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), timeoutPer);
      const res = await fetch(api, { signal:ctrl.signal });
      clearTimeout(t);
      if(!res.ok) continue;
      const ct = res.headers.get('content-type') || '';
      let json = null;
      if(ct.includes('application/json')) json = await res.json();
      if(!json) continue;
      let arr = [];
      if(Array.isArray(json)) arr = json;
      else if(json.data && Array.isArray(json.data)) arr = json.data;
      else if(json.products && Array.isArray(json.products)) arr = json.products;
      else if(json.entries && Array.isArray(json.entries)) arr = json.entries;
      else {
        const top = Object.keys(json||{}).slice(0, limit);
        arr = top.map(k => ({ id: k, title: k }));
      }
      arr.slice(0, limit).forEach((it, idx) => {
        const id = it.id ? String(it.id) : ('task_' + Math.random().toString(36).slice(2,8));
        const title = it.title || it.name || it.API || ('Task ' + (results.length+1));
        const url = it.url || it.link || it.homepage || ('https://example.com/?ref=' + encodeURIComponent(id));
        const secs = 30 + (idx%3)*10;
        const reward = 100 + Math.floor(Math.random()*200);
        results.push({ id, title, url, secs, reward, source: api });
      });
    } catch(e){ continue; }
    if(results.length >= limit) break;
  }
  const seen = new Set(); const out = [];
  for(const r of results){
    if(seen.has(r.id)) continue;
    seen.add(r.id);
    out.push(r);
    if(out.length >= limit) break;
  }
  return out;
}

/* ===== navigation state (fixes back behavior) ===== */
let currentView = 'home';
const viewStack = [];
function pushView(v){ viewStack.push(currentView); currentView = v; }
function popView(){ const prev = viewStack.pop(); if(prev) { currentView = prev; return prev; } return null; }

/* ===== UI helpers ===== */
function setTitle(t){ if(el('hostTitle')) el('hostTitle').textContent = t || 'Hosted view'; }
function setVIPLabel(){
  const qp = combinedQP();
  const vip = (qp.vip || qp.vip_level) || (profile && profile.vip_level) || (readLocalProfile() && readLocalProfile().vip_level) || '';
  el('vipInfo').textContent = vip ? ('VIP: ' + vip) : 'VIP: —';
}

/* ===== core renderers/flows ===== */

function renderHome(){
  pushView('home');
  setTitle('Hosted view');
  setVIPLabel();
  setMain(`<div class="small">Hosted — waiting for instruction. If parent opened an ad/task it will appear automatically.</div>`);
  currentView = 'home';
}

/* ---- PARENT_TASKS store + renderer (NEW, non-invasive) ---- */
let PARENT_TASKS = null;
function renderTasksFromParent(tasks){
  try{
    PARENT_TASKS = Array.isArray(tasks) ? tasks.slice() : [];
    const html = PARENT_TASKS.map(t=>{
      const id = t.id || t.task_id || ('task_' + Math.random().toString(36).slice(2,8));
      const title = escapeHtml(t.title || t.name || ('Task ' + id));
      const meta = escapeHtml((t.tag||'') + (t.secs ? (' · stay ' + t.secs + 's') : '') + (t.reward ? (' · Reward ' + t.reward + ' G') : ''));
      const urlEnc = encodeURIComponent(t.url || t.link || '');
      const idEnc = encodeURIComponent(id);
      const secs = Number(t.secs || 30);
      const reward = Number(t.reward || t.base || 0);
      return `<div class="card-item" role="article" data-task-id="${id}">
        <div>
          <strong>${title}</strong>
          <div class="small">${meta}</div>
        </div>
        <div>
          <button class="btn do-task" data-id="${idEnc}" data-url="${urlEnc}" data-secs="${secs}" data-reward="${reward}">Do</button>
        </div>
      </div>`;
    }).join('');

    const tasksHtml = `<div class="small">Tasks provided by parent (max ${TASKS_LIMIT}/day).</div>
      <div class="task-list" id="taskList">${html}</div>
      <div style="margin-top:12px;text-align:center"><div id="taskBanner"></div></div>`;

    setMain(tasksHtml);
    injectAdsterraInto('taskBanner');

    // wire buttons (remove duplicates safely)
    Array.from(document.querySelectorAll('.do-task')).forEach(b=>{
      b.replaceWith(b.cloneNode(true));
    });
    Array.from(document.querySelectorAll('.do-task')).forEach(b=>{
      b.addEventListener('click', async ()=>{
        const id = decodeURIComponent(b.getAttribute('data-id'));
        const url = decodeURIComponent(b.getAttribute('data-url'));
        const secs = Number(b.getAttribute('data-secs')||30);
        const rewardBase = Number(b.getAttribute('data-reward')||0);
        postParent({ type:'task_started', payload:{ task_id: id, task_type: 'auto' } });
        await runTaskFlow({ task_id: id, url, secs, rewardBase, _source: 'ui' });
      });
    });

  }catch(e){
    console.warn('renderTasksFromParent error', e);
    setMain(`<div class="small">Unable to render tasks from parent.</div>`);
  }
}

/* original renderTaskBoard kept — we'll patch it non-destructively below */
async function renderTaskBoard(qp){
  pushView('tasks');
  setTitle('Task Board');
  setVIPLabel();
  const done = getTasksDone();
  if(done.length >= TASKS_LIMIT){
    setMain(`<div class="small">You have completed today's tasks. New tasks will appear tomorrow.</div>`);
    currentView = 'tasks';
    return;
  }
  setMain(`<div class="small">Loading tasks…</div>`);
  const tasks = await fetchTasks(TASKS_LIMIT);
  if(!tasks || !tasks.length){
    setMain(`<div class="small">No tasks available right now. Try again later.</div>`);
    currentView = 'tasks';
    return;
  }
  const html = tasks.map(t=>`
    <div class="card-item">
      <div>
        <strong>${escapeHtml(t.title)}</strong>
        <div class="small">${escapeHtml(t.source)} · stay ${t.secs}s · Reward ${t.reward} G</div>
      </div>
      <div>
        <button class="btn do-task" data-id="${encodeURIComponent(t.id)}" data-url="${encodeURIComponent(t.url)}" data-secs="${t.secs}" data-reward="${t.reward}">Do</button>
      </div>
    </div>
  `).join('');
  const tasksHtml = `<div class="small">Tasks auto-generated (max ${TASKS_LIMIT}/day). Starting a daily task will notify the parent and hide other daily tasks there.</div>
    <div class="task-list" style="margin-top:12px">${html}</div>
    <div style="margin-top:12px;text-align:center"><div id="taskBanner"></div></div>`;
  setMain(tasksHtml);
  currentView = 'tasks';
  injectAdsterraInto('taskBanner');
  Array.from(document.querySelectorAll('.do-task')).forEach(b=>{
    b.addEventListener('click', async ()=>{
      const id = decodeURIComponent(b.getAttribute('data-id'));
      const url = decodeURIComponent(b.getAttribute('data-url'));
      const secs = Number(b.getAttribute('data-secs')||30);
      const rewardBase = Number(b.getAttribute('data-reward')||120);
      postParent({ type:'task_started', payload:{ task_id: id, task_type: 'auto' } });
      await runTaskFlow({ task_id: id, url, secs, rewardBase, _source: detectSource(qp) || 'ui' });
    });
  });
  currentView = 'tasks';
}

/* ===== Replace global renderTaskBoard with patched version that prefers PARENT_TASKS ===== */
try{
  const _origRenderTaskBoard = renderTaskBoard;
  renderTaskBoard = async function(qp){
    if(PARENT_TASKS && Array.isArray(PARENT_TASKS) && PARENT_TASKS.length > 0){
      try{ renderTasksFromParent(PARENT_TASKS); currentView='tasks'; return; }catch(e){ console.warn('patched render fallback', e); }
    }
    return await _origRenderTaskBoard(qp);
  };
}catch(e){ console.warn('unable to patch renderTaskBoard', e); }

/* ===== runTaskFlow (kept from original, unchanged) ===== */
async function runTaskFlow(opts){
  pushView('task');
  setTitle('Task');
  setVIPLabel();
  const taskId = opts.task_id || ('task_' + Math.random().toString(36).slice(2,8));
  const secs = Number(opts.secs || 30);
  const url = opts.url || '';
  setMain(`<div class="small">Task ${escapeHtml(taskId)} — open the target and remain for <strong>${secs}s</strong> to verify.</div>
    <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><button id="openBtn" class="btn">Open & Start</button><button id="cancelBtn" class="btn ghost">Cancel</button></div>
    <div id="taskNote" class="small" style="margin-top:12px"></div>`);
  currentView = 'task';

  const openBtn = el('openBtn'), cancelBtn = el('cancelBtn'), note = el('taskNote');
  let finished = false, timer = null, popup = null, poll = null;

  openBtn.addEventListener('click', async ()=>{
    cancelBtn.style.display = 'none';
    openBtn.disabled = true;
    note.textContent = `Opening target — please stay ${secs}s for verification...`;

    try{ popup = window.open(url, '_blank'); }catch(e){ popup = null; }

    if(!popup){
      const payload = {
        task_id: taskId,
        status: 'popup_blocked',
        reward: 0,
        base: 0,
        vip_bonus: 0,
        user_id: (profile && profile.user_id) || null
      };
      postParent({ type:'task_complete', payload });
      saveTaskState && saveTaskState({ date: nowDay(), status: 'idle' });
      note.textContent = 'Popup blocked or invalid link. Returning...';
      await sleep(700);
      postParent({ type:'close_hosted', reason:'popup_blocked', payload });
      return;
    }

    if(!profile) await requestProfileFromParent(1500).catch(()=>null);
    const vip = vipFrom({});
    timer = setTimeout(async ()=>{
      if(finished) return;
      finished = true;
      const rewardObj = calcTaskReward(vip);
      addTaskDone(taskId);
      const payload = {
        task_id: taskId,
        reward: rewardObj.total,
        base: rewardObj.base,
        vip_bonus: rewardObj.vip_bonus,
        vip_level: vip || null,
        user_id: (profile && profile.user_id) || null,
        status: 'completed'
      };
      postParent({ type:'task_complete', payload });
      note.textContent = 'Task completed. Returning...';
      saveTaskState && saveTaskState({ date: nowDay(), status: 'completed' });
      await sleep(700);
      postParent({ type:'close_hosted', reason:'task_done', payload });
    }, secs * 1000);

    poll = setInterval(()=> {
      try {
        if(popup.closed && !finished){
          finished = true;
          if(timer) clearTimeout(timer);
          clearInterval(poll);
          const payload = {
            task_id: taskId,
            status: 'unverified_popup_closed',
            reward: 0,
            base: 0,
            vip_bonus: 0,
            user_id: (profile && profile.user_id) || null
          };
          postParent({ type:'task_complete', payload });
          saveTaskState && saveTaskState({ date: nowDay(), status: 'idle' });
          note.textContent = 'Popup closed before verification. Returning...';
          sleep(700).then(()=> postParent({ type:'close_hosted', reason:'popup_closed', payload }));
        }
      } catch(e){}
    }, 700);
  });

  cancelBtn.addEventListener('click', ()=>{
    postParent({ type:'task_skipped', payload: { task_id: taskId } });
    popView();
    renderTaskBoard({});
  });

  window.addEventListener('beforeunload', ()=> { if(!finished) postParent({ type:'task_incomplete', payload:{ task_id: taskId } }); });
}

/* ===== ad flow (kept) ===== */
async function renderAdFlow(qp){
  pushView('ad');
  setTitle('Watch Ad');
  setVIPLabel();

  const watched = getWatched();
  if(watched.length >= ADS_LIMIT){
    const now = new Date(), tom = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);
    const msLeft = tom - now; const hrs = Math.floor(msLeft/3600000); const mins = Math.floor((msLeft%3600000)/60000);
    setMain(`<div class="small">Daily ad limit reached. Next ads unlock in ${hrs}h ${mins}m</div>`);
    currentView = 'ad';
    return;
  }
  if(!canOpenAdNow()){
    const rem = ADS_COOLDOWN_MS - (Date.now() - getLastAdTs()); const mins = Math.ceil(rem/60000);
    setMain(`<div class="small">Cooldown active. Try again in ~${mins} minute(s).</div>`);
    currentView = 'ad';
    return;
  }

  let provider = { ok:false };
  try { provider = await tryLoadAdsterra(ADSTERRA_ZONE_URL, 3500); } catch(e){ provider={ok:false}; }
  if(!provider.ok){
    try { provider = await tryLoadVideoSrc(GOOGLE_FALLBACK_VIDEO, 3000); } catch(e){ provider={ok:false}; }
  }
  if(!provider.ok){
    provider = { ok:true, type:'fallback', node: (function(){ const d=document.createElement('div'); d.innerHTML='<div class="small" style="padding:12px">Ad preview (fallback)</div>'; return d; })() };
  }

  if(!profile) profile = readLocalProfile() || null;
  if(!profile) await requestProfileFromParent(1500).catch(()=>null);
  setVIPLabel();
  const qp = qp || combinedQP();
  const vip = vipFrom(qp);
  const rewardObj = calcAdReward(vip);

  const adId = qp.ad_id || ('host_ad_'+Math.floor(Math.random()*999999));
  addWatched(adId);
  setLastAdTs(Date.now());

  const nodeHtmlId = 'adPlayerNode';
  setMain(`<div class="small">Watching: <strong>${escapeHtml(adId)}</strong> — Reward: <strong>${rewardObj.total} G</strong> <div class="small">(${rewardObj.base} base + ${rewardObj.vip_bonus} VIP)</div></div>
    <div style="margin-top:12px" id="${nodeHtmlId}" class="ad-player"><div class="small">Loading ad…</div></div>
    <div style="margin-top:12px;text-align:center"><div id="adPlayerAdsenseHolder"></div></div>
    <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><div class="countdown" id="adCount">${ADS_DURATION}</div></div>
    <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><button id="claimBtn" class="btn" disabled>Claim</button><button id="retBtn" class="btn ghost hidden">Return</button></div>
    <div class="note" id="adNote">Auto-completes after ${ADS_DURATION}s</div>`);

  const container = el(nodeHtmlId);
  if(provider.node){
    container.innerHTML = '';
    container.appendChild(provider.node);
    if(provider.type === 'video'){ try{ provider.node.play().catch(()=>{}); }catch(e){} }
  }

  // inject AdSense + amp-ad
  try{
    const holder = el('adPlayerAdsenseHolder');
    if(holder){
      holder.innerHTML = `
        <!-- GainGrid_Display_Horizontal (injected) -->
        <ins class="adsbygoogle"
             style="display:inline-block;width:468px;height:60px"
             data-ad-client="ca-pub-2309008538670900"
             data-ad-slot="4194843603"></ins>
      `;
      try{ (adsbygoogle = window.adsbygoogle || []).push({}); }catch(e){ console.warn('adsbygoogle push failed', e); }
      const ampWrap = document.createElement('div');
      ampWrap.style.marginTop = '6px';
      ampWrap.innerHTML = `
        <amp-ad
             layout="fixed"
             width="468"
             height="60"
             type="adsense"
             data-ad-client="ca-pub-2309008538670900"
             data-ad-slot="4194843603">
        </amp-ad>
      `;
      holder.appendChild(ampWrap);
    }
  }catch(e){ console.warn('inject Adsense failed', e); }

  const bannerHolder = document.createElement('div');
  bannerHolder.style.position = 'absolute';
  bannerHolder.style.top = '10px';
  bannerHolder.style.left = '50%';
  bannerHolder.style.transform = 'translateX(-50%)';
  bannerHolder.style.zIndex = '5';
  bannerHolder.id = 'adsterBannerHolder';
  injectAdsterraIntoElement(bannerHolder);
  container.parentElement.appendChild(bannerHolder);

  const countEl = el('adCount'), claimBtn = el('claimBtn'), retBtn = el('retBtn'), adNote = el('adNote');
  let secs = ADS_DURATION; let completed=false;
  const timerId = setInterval(()=>{
    secs--; if(countEl) countEl.textContent = secs;
    if(secs <= 0){
      clearInterval(timerId);
      if(claimBtn) claimBtn.disabled = false;
      adNote.textContent = 'Ad finished. Press Claim or wait to auto-send.';
      setTimeout(()=>{
        if(completed) return;
        completed = true;
        const payload = {
          ad_id: adId,
          reward: rewardObj.total,
          base: rewardObj.base,
          vip_bonus: rewardObj.vip_bonus,
          vip_level: vip || null,
          user_id: (profile && profile.user_id) || null
        };
        postParent({ type:'ad_complete', payload });
        if(retBtn){ retBtn.classList.remove('hidden'); retBtn.textContent = (detectSource(qp) === 'ui' ? 'Return to Game' : 'Close'); }
      }, 900);
      setTimeout(()=>{ postParent({ type:'close_hosted', reason:'ad_done' }); try{ if(window.close) window.close(); }catch(e){} }, 1500);
    }
  }, 1000);

  claimBtn.addEventListener('click', ()=>{
    if(completed) return;
    completed = true;
    const payload = {
      ad_id: adId,
      reward: rewardObj.total,
      base: rewardObj.base,
      vip_bonus: rewardObj.vip_bonus,
      vip_level: vip || null,
      user_id: (profile && profile.user_id) || null
    };
    postParent({ type:'ad_complete', payload });
    if(retBtn){ retBtn.classList.remove('hidden'); retBtn.textContent = (detectSource(qp) === 'ui' ? 'Return to Game' : 'Close'); }
  });

  retBtn.addEventListener('click', ()=> {
    postParent({ type:'close_hosted', reason:'user_return' });
  });

  currentView = 'ad';
}

/* ===== Adsterra injection helpers (kept) ===== */
function injectAdsterraInto(idOrElem){
  let holder = null;
  if(typeof idOrElem === 'string') holder = document.getElementById(idOrElem);
  else holder = idOrElem;
  if(!holder) return;
  holder.innerHTML = '';
  const wrap = document.createElement('div');
  wrap.style.width = '468px';
  wrap.style.maxWidth = '100%';
  wrap.style.height = '60px';
  wrap.style.margin = '0 auto';
  wrap.style.overflow = 'hidden';
  const s1 = document.createElement('script');
  s1.type = 'text/javascript';
  s1.text = "atOptions = { 'key' : '" + ADSTER_SCRIPT_KEY + "', 'format' : 'iframe', 'height' : 60, 'width' : 468, 'params' : {} };";
  wrap.appendChild(s1);
  const s2 = document.createElement('script');
  s2.type = 'text/javascript';
  s2.src = ADSTER_SCRIPT_SRC;
  wrap.appendChild(s2);
  holder.appendChild(wrap);
}
function injectAdsterraIntoElement(elem){
  try{
    const s1 = document.createElement('script');
    s1.type = 'text/javascript';
    s1.text = "atOptions = { 'key' : '" + ADSTER_SCRIPT_KEY + "', 'format' : 'iframe', 'height' : 60, 'width' : 468, 'params' : {} };";
    elem.appendChild(s1);
    const s2 = document.createElement('script');
    s2.type = 'text/javascript';
    s2.src = ADSTER_SCRIPT_SRC;
    elem.appendChild(s2);
  }catch(e){ console.warn('injectAdsterraIntoElement failed', e); }
}

/* ===== routing and helpers ===== */
function qsParse(s){ if(!s) return {}; return s.replace(/^\?/,'').split('&').filter(Boolean).reduce((o,p)=>{ const i=p.indexOf('='); if(i<0) o[decodeURIComponent(p)]=''; else o[decodeURIComponent(p.slice(0,i))]=decodeURIComponent(p.slice(i+1)); return o; }, {}); }
function getHashQP(){ if(!location.hash) return {}; const h = location.hash.replace(/^#/,''); const parts = h.split('?'); return qsParse(parts[1]||''); }
function getSearchQP(){ return qsParse(location.search || ''); }
function combinedQP(){ return Object.assign({}, getHashQP(), getSearchQP()); }
function detectSource(qp){ qp = qp || combinedQP(); if(qp._source === 'ui') return 'ui'; if(qp.start) return 'deeplink'; if(qp.ad_id || qp.task_id){ if(qp.user_id || qp.vip || qp.vip_level) return 'ui'; return 'deeplink'; } return 'ui'; }
function decodeStart(raw){
  if(!raw) return null;
  try{
    const norm = raw.replace(/-/g,'+').replace(/_/g,'/');
    const json = atob(norm); return JSON.parse(json);
  }catch(e){
    try{ return JSON.parse(decodeURIComponent(raw)); }catch(e){ return null; }
  }
}

/* ===== HOSTED: readiness handshake + small debug badge behaviour (ensures parent waits) ===== */
(function hostedReadyAndDebug(){
  try{
    const dbg = el('hostedDbg');
    if(dbg) dbg.textContent = 'hosted:init';
    function announceReady(){
      try{
        postParent({ type: 'hosted_ready', payload: { ts: Date.now() } });
        const d = el('hostedDbg');
        if(d) d.textContent = 'hosted:ready';
      }catch(e){ console.warn('announceReady failed', e); }
    }
    if(document.readyState === 'complete' || document.readyState === 'interactive'){ setTimeout(announceReady, 80); }
    else document.addEventListener('DOMContentLoaded', ()=> setTimeout(announceReady, 80));
    window.__hostedDebug = function(msg){ try{ const d = el('hostedDbg'); if(d) d.textContent = 'hosted:' + (msg || '').toString().slice(0,30); console.log('hostedDbg:', msg); }catch(e){} };
  }catch(e){ console.warn('hostedReadyAndDebug init error', e); }
})();

/* ===== parent message handler (enhanced; accepts tasks in start_payload) ===== */
window.addEventListener('message', function(ev){
  try{
    const d = ev.data || {};
    if(!d || typeof d !== 'object') return;
    // update debug
    try{ if(window.__hostedDebug) window.__hostedDebug(d.type || 'msg'); }catch(e){}

    if(d.type === 'profile_response' && d.payload){ profile = d.payload; setVIPLabel(); }

    // handle start_payload (ads OR tasks sent by parent)
    if(d.type === 'start_payload' && d.payload){
      const p = d.payload || {};
      // if parent sent tasks array -> render them (authoritative)
      if(Array.isArray(p.tasks) && p.tasks.length > 0){
        // normalize tasks
        const mapped = p.tasks.map(t => ({
          id: t.id || t.task_id || ('task_' + Math.random().toString(36).slice(2,8)),
          title: t.title || t.name || ('Task ' + (t.id||'')),
          secs: t.secs || t.duration || 30,
          reward: t.reward || t.base || 0,
          url: t.url || t.link || '',
          tag: t.tag || t.type || ''
        }));
        PARENT_TASKS = mapped;
        try{ if(window.__hostedDebug) window.__hostedDebug('start:tasks'); }catch(e){}
        renderTasksFromParent(PARENT_TASKS);
        return;
      }

      // else treat as single ad/task payload (authoritative)
      if(p && (p.id || p.ad_id || p.task_id)){
        // normalize incoming object used by renderPlayerUsingIncoming()
        incoming = Object.assign({}, p);
        incoming.from = incoming.from || 'ui';
        originSource = 'ui';
        try{ if(window.__hostedDebug) window.__hostedDebug('start:'+ (incoming.id || incoming.ad_id || incoming.task_id || '').toString().slice(0,12)); }catch(e){}
        // if it's an ad-like payload, render ad flow using provided values
        if(p.ad_id || p.type === 'ad' || p.isAd){
          // set hash so router handles it similarly (keeps code paths unified)
          location.hash = '#/ad?ad_id=' + encodeURIComponent(p.id || p.ad_id || p.task_id || '');
          router();
          return;
        }
        // if it's a task payload, open task view
        if(p.task_id || p.type === 'task' || p.isTask){
          location.hash = '#/task?task_id=' + encodeURIComponent(p.id || p.task_id || p.ad_id || '');
          router();
          return;
        }

        // fallback: attempt to render ad flow with qp merged
        router();
        return;
      }
    }

    if(d.type === 'open_ad' && d.payload && d.payload.ad_id){ location.hash = '#/ad?ad_id='+encodeURIComponent(d.payload.ad_id)+'&_source=ui'; router(); return; }
    if(d.type === 'open_task' && d.payload && d.payload.task_id){ location.hash = '#/task?task_id='+encodeURIComponent(d.payload.task_id)+'&_source=ui'; router(); return; }

    if(d.type === 'request_close_from_parent' || d.type === 'request_close'){ try{ if(window.close) window.close(); }catch(e){} return; }

  }catch(err){ console.warn('Hosted message handler error', err); }
}, false);

/* ===== incoming player helpers (ads & tasks invoked via parent or deeplink) ===== */
let incoming = null;
let originSource = 'ui';

function renderPlayerUsingIncoming(){
  if(!incoming){ setMain(`<div class="small">No ad/task data received. Waiting for parent or deeplink.</div>`); return; }
  const isUi = (incoming.from === 'ui');
  const mainBtnLabel = isUi ? 'Claim' : 'Return to Bot';
  setVIPLabel();
  setMain(`
    <div class="small">ID: <strong>${escapeHtml(incoming.id || incoming.ad_id || incoming.task_id || '—')}</strong></div>
    <div style="margin-top:10px" class="ad-player" id="adPlayer"><div class="small">Loading ad…</div></div>
    <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center">
      <div>
        <div class="small">Base: ${incoming.base||0} · VIP: ${incoming.vip_bonus||0}</div>
        <div style="font-weight:700">Total: ${incoming.reward||0} G</div>
        <div class="note" id="adNote">Auto-completes after <span id="adCount">${incoming.secs||0}</span>s</div>
      </div>
      <div style="display:flex;flex-direction:column;gap:8px">
        <button id="mainBtn" class="btn">${mainBtnLabel}</button>
        <button id="closeBtn" class="btn ghost">Close</button>
      </div>
    </div>
    <div id="adsenseHolder" style="margin-top:10px;text-align:center"></div>
  `);

  injectAdsIntoPlayer();

  const mainBtn = el('mainBtn'), closeBtn = el('closeBtn');
  mainBtn && mainBtn.addEventListener('click', ()=> {
    if(incoming.from === 'ui'){
      // only allow claim when timer reached 0 - but finalizeAndSend will do checks
      if(remaining && remaining > 0){
        setStatus && setStatus('Please wait until the timer finishes to claim', true);
        return;
      }
      finalizeAndSend();
    } else {
      finalizeAndSend({ toBot:true });
    }
  });
  closeBtn && closeBtn.addEventListener('click', ()=>{
    postParent({ type:'close_hosted', reason:'user_closed', payload:{ id: incoming.id } });
    try{ if(window.close) window.close(); }catch(e){}
  });

  startCountdown(incoming.secs || 0);
}

/* injectAdSense + Adsterra into ad player (for renderPlayerUsingIncoming) */
function injectAdsIntoPlayer(){
  try{
    const holder = el('adsenseHolder');
    if(holder){
      holder.innerHTML = `
        <ins class="adsbygoogle"
             style="display:inline-block;width:468px;height:60px"
             data-ad-client="ca-pub-2309008538670900"
             data-ad-slot="4194843603"></ins>
      `;
      try{ (adsbygoogle = window.adsbygoogle || []).push({}); }catch(e){ console.warn('adsbygoogle push failed', e); }
      const ast = document.createElement('div'); ast.style.marginTop='6px'; el('adsenseHolder').appendChild(ast); injectAdsterraIntoElement(ast);
    }
  }catch(e){}
}

/* countdown + finalize helpers for incoming player */
let countdownTimer = null, remaining = 0;
function startCountdown(secs){
  if(countdownTimer) clearInterval(countdownTimer);
  remaining = Number(secs) || 0;
  const disp = el('adCount'); if(disp) disp.textContent = remaining;
  countdownTimer = setInterval(()=>{
    remaining--; if(disp) disp.textContent = remaining;
    if(remaining <= 0){
      clearInterval(countdownTimer); countdownTimer = null;
      finalizeAndSend();
    }
  }, 1000);
}

async function finalizeAndSend(opts){
  opts = opts || {};
  if(!incoming) return;
  const payload = {
    id: incoming.id || incoming.ad_id || incoming.task_id,
    task_id: incoming.id || incoming.task_id || null,
    ad_id: incoming.id || incoming.ad_id || null,
    secs: incoming.secs || 0,
    reward: incoming.reward || 0,
    base: incoming.base || 0,
    vip_bonus: incoming.vip_bonus || 0,
    vip_level: incoming.vip_level || null,
    user_id: incoming.user_id || null,
    status: 'completed',
    ts: Date.now()
  };

  if(incoming.from === 'ui'){
    try{ postParent({ type:'ad_complete', payload }); postParent({ type:'task_complete', payload }); postParent({ type:'task_verified', payload }); setTimeout(()=> postParent({ type:'close_hosted', reason:'done', payload }), 300); }catch(e){ console.warn('finalize postParent failed', e); }
  } else {
    try{ replyToBot('ad_complete', payload).catch(()=>{}); postParent({ type:'ad_complete', payload }); setTimeout(()=> { try{ if(window.close) window.close(); }catch(e){} }, 600); }catch(e){ console.warn('finalize bot reply failed', e); }
  }

  // cleanup parent tasks/ads store so new ones can be sent
  try{
    const ads = JSON.parse(localStorage.getItem(KEY_ADS_DATA) || '[]');
    if(Array.isArray(ads) && payload.id){
      const rem = ads.filter(a=> (a.id || '') !== payload.id );
      localStorage.setItem(KEY_ADS_DATA, JSON.stringify(rem));
    }
  }catch(e){}
  if(el('adNote')) el('adNote').textContent = 'Completed — returning...';
}

/* replyToBot helper (reuses sendToBot logic when present) */
async function replyToBot(action, payload){
  const data = { action: action, payload: payload || {}, meta:{ ts: Date.now() } };
  try{
    if(window.Telegram && Telegram.WebApp && typeof Telegram.WebApp.sendData === 'function'){
      Telegram.WebApp.sendData(JSON.stringify(data));
      setStatus && setStatus('Sent to bot (WebApp.sendData)', true);
      return { ok:true, via:'webapp' };
    }
  }catch(e){ console.warn('replyToBot sendData failed', e); }
  try{
    const b = btoa(JSON.stringify(data)).replace(/=+$/,'');
    const url = "https://t.me/" + (typeof BOT_USERNAME !== 'undefined' ? BOT_USERNAME : 'GridGain_bot') + "?start=" + encodeURIComponent(b);
    window.open(url, '_blank');
    return { ok:true, via:'deeplink' };
  }catch(e){ console.warn('replyToBot deeplink failed', e); return { ok:false }; }
}

/* ===== router & startup (kept) ===== */
async function router(){
  ensureDayReset && ensureDayReset();
  profile = profile || readLocalProfile() || null;
  setVIPLabel();
  const qp = combinedQP();

  if(qp.start){
    const decoded = decodeStart(qp.start);
    if(decoded){
      const action = (decoded.action || decoded.cmd || decoded.type || '').toString().toLowerCase();
      const payload = decoded.payload || decoded.data || decoded;
      if(action.includes('ad') || action.includes('watch')){
        if(payload && (payload.ad_id || payload.id)) qp.ad_id = payload.ad_id || payload.id;
        qp.vip = qp.vip || payload.vip || payload.vip_level;
        await renderAdFlow(qp);
        return;
      } else if(action.includes('task')){
        if(payload && (payload.task_id || payload.id)) qp.task_id = payload.task_id || payload.id;
        qp.vip = qp.vip || payload.vip || payload.vip_level;
        await renderTaskBoard(qp);
        return;
      }
    }
  }

  if(qp.ad_id || qp.id || (location.hash && location.hash.toLowerCase().includes('/ad'))){
    await renderAdFlow(qp);
    return;
  }
  if(qp.task_id || qp.id || (location.hash && location.hash.toLowerCase().includes('/task'))){
    await renderTaskBoard(qp);
    return;
  }

  renderHome();
}

setTimeout(()=> { generateDailyAds(); router(); }, 120);
window.addEventListener('hashchange', ()=> router());

/* Expose small helpers */
window.requestHostedVerification = function(taskId, opts){ try{ postParent({ type:'request_parent_verify', payload:{ task_id: taskId, ...opts } }); }catch(e){} };
window.sendToHostedFrame = function(msg){ try{ postParent(msg); }catch(e){} };
window.isHostedFrameAvailable = function(){ return true; };

/* End hosted script */
</script>
</body>
</html>