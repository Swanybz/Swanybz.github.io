<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>GainGrid Hosted — Task/Ad Player</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

<!-- AdSense core (exact snippet provided by you) -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2309008538670900"
     crossorigin="anonymous"></script>

<style>
  /* Minimal styling — kept compatible with your previous markup */
  body,html{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;color:#fff;background:linear-gradient(135deg,#0f1419,#1a2332);display:flex;align-items:center;justify-content:center}
  .card{width:420px;max-width:92vw;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .back-btn{background:transparent;border:0;color:rgba(255,255,255,0.8);cursor:pointer;font-weight:600}
  h2{margin:0;font-size:18px}
  .small{font-size:13px;color:rgba(255,255,255,0.75)}
  .ad-player{width:100%;height:260px;border-radius:8px;overflow:hidden;background:#000;display:flex;align-items:center;justify-content:center;position:relative}
  .ad-player iframe,.ad-player video{width:100%;height:100%;border:0}
  .note{margin-top:8px;color:rgba(255,255,255,0.6);font-size:13px}
  .countdown{font-weight:700;font-size:20px;color:#fff}
  .btn{padding:10px 12px;border-radius:8px;background:linear-gradient(45deg,#ff6b9d,#c471ed);border:none;color:#fff;cursor:pointer;font-weight:700}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .hidden{display:none}
</style>
</head>
<body>
  <div class="card" id="root">
    <div class="topbar">
      <button id="backBtn" class="back-btn">← Back</button>
      <h2 id="hostTitle">Hosted</h2>
      <div class="small" id="vipInfo">VIP: —</div>
    </div>

    <div id="main" class="small">Initializing…</div>
  </div>

<script>
/* Hosted page — single-file behavior
   - Prefers parent-sent payload (postMessage) for timer/reward/id.
   - Falls back to query params if opened from bot deeplink (then randomize secs/reward).
   - Sends results back to parent (postMessage) or to bot (Telegram.WebApp.sendData / deeplink) accordingly.
   - Auto-closes only after the exact passed secs.
*/

/* ==== Config (kept names) ==== */
const ADSTER_SCRIPT_KEY = 'a8702b8b4c48420a3815542007f1c0df';
const ADSTER_SCRIPT_SRC = "//www.highperformanceformat.com/" + ADSTER_SCRIPT_KEY + "/invoke.js";
const VIP_BONUS = { basic:20, silver:40, gold:60, premium:100 };

/* ==== small helpers ==== */
const el = id => document.getElementById(id);
function nowDay(){ return new Date().toISOString().slice(0,10); }
function qsParse(q){ if(!q) return {}; return q.replace(/^\?/,'').split('&').filter(Boolean).reduce((o,p)=>{ const i=p.indexOf('='); if(i<0) o[decodeURIComponent(p)]=''; else o[decodeURIComponent(p.slice(0,i))]=decodeURIComponent(p.slice(i+1)); return o; }, {}); }
function combinedQP(){ return Object.assign({}, qsParse(location.search||''), qsParse(location.hash.replace(/^#/,'').split('?')[1]||'')); }
function escapeHtml(s){ if(!s && s !== 0) return ''; return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function postParent(msg){ try{ if(window.parent && window.parent !== window) window.parent.postMessage(msg, '*'); }catch(e){} try{ if(window.opener && !window.opener.closed) window.opener.postMessage(msg,'*'); }catch(e){} try{ console.log('postParent:', msg); }catch(e){} }

/* ==== reply to bot (when opened inside Telegram WebApp or direct deeplink) ==== */
async function replyToBot(action, payload){
  const data = { action: action, payload: payload || {}, meta:{ ts: Date.now() } };
  try{
    if(window.Telegram && Telegram.WebApp && typeof Telegram.WebApp.sendData === 'function'){
      Telegram.WebApp.sendData(JSON.stringify(data));
      setStatus && setStatus('Sent to bot (WebApp.sendData)', true);
      return { ok:true, via:'webapp' };
    }
  }catch(e){ console.warn('replyToBot sendData failed', e); }
  // fallback: open deep-link to bot with payload
  try{
    const b = btoa(JSON.stringify(data)).replace(/=+$/,'');
    const url = "https://t.me/" + (typeof BOT_USERNAME !== 'undefined' ? BOT_USERNAME : 'GridGain_bot') + "?start=" + encodeURIComponent(b);
    window.open(url, '_blank');
    return { ok:true, via:'deeplink' };
  }catch(e){ console.warn('replyToBot deeplink failed', e); return { ok:false }; }
}

/* ==== UI helpers ==== */
function setMain(html){ if(el('main')) el('main').innerHTML = html; }
function setVIPLabel(vip){ if(el('vipInfo')) el('vipInfo').textContent = vip ? ('VIP: ' + vip) : 'VIP: —'; }

/* ==== state ==== */
let originSource = 'ui'; // 'ui' or 'bot' (deeplink)
let incoming = null;     // object that holds { id, secs, reward, base, vip_bonus, vip_level, user_id, from }
let countdownTimer = null;
let remaining = 0;

/* ==== decide initial source & data ==== */
function initIncomingFromQueryOrHash(){
  const qp = combinedQP();
  if(Object.keys(qp).length === 0) return null;
  // If query contains from=bot or bot param, treat as deeplink
  if(qp.from === 'bot' || qp._from === 'bot' || qp.bot === '1' || qp.deeplink === '1'){
    originSource = 'bot';
  } else if(qp._source === 'ui' || qp.source === 'ui' || qp.from === 'ui') {
    originSource = 'ui';
  }
  // collect values
  const obj = {
    id: qp.id || qp.ad_id || qp.task_id || null,
    secs: qp.secs ? Number(qp.secs) : (qp.s ? Number(qp.s) : null),
    reward: qp.reward ? Number(qp.reward) : (qp.r ? Number(qp.r) : null),
    base: qp.base ? Number(qp.base) : null,
    vip_bonus: qp.vip_bonus ? Number(qp.vip_bonus) : null,
    vip_level: qp.vip || qp.vip_level || null,
    user_id: qp.user_id || qp.u || null,
    from: originSource
  };
  return obj;
}

/* ==== function to render the ad/task UI using only incoming data ==== */
function renderPlayerUsingIncoming(){
  if(!incoming) {
    setMain(`<div class="small">No ad/task data received. Waiting for parent or deeplink.</div>`);
    return;
  }

  // determine label for action button
  const isUi = (incoming.from === 'ui');
  const mainBtnLabel = isUi ? 'Claim' : 'Return to Bot';

  // show ad player and info
  setVIPLabel(incoming.vip_level || '—');
  setMain(`
    <div class="small">ID: <strong>${escapeHtml(incoming.id || '—')}</strong></div>
    <div style="margin-top:10px" class="ad-player" id="adPlayer">
      <div class="small">Loading ad…</div>
    </div>
    <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center">
      <div>
        <div class="small">Base: ${incoming.base||0} · VIP: ${incoming.vip_bonus||0}</div>
        <div style="font-weight:700">Total: ${incoming.reward||0} G</div>
        <div class="note" id="adNote">Auto-completes after <span id="adCount">${incoming.secs||0}</span>s</div>
      </div>
      <div style="display:flex;flex-direction:column;gap:8px">
        <button id="mainBtn" class="btn">${mainBtnLabel}</button>
        <button id="closeBtn" class="btn ghost">Close</button>
      </div>
    </div>
    <div id="adsenseHolder" style="margin-top:10px;text-align:center"></div>
  `);

  // inject ad (AdSense + Adsterra fallback)
  injectAdsIntoPlayer();

  // wiring buttons
  const mainBtn = el('mainBtn'), closeBtn = el('closeBtn');
  mainBtn && mainBtn.addEventListener('click', ()=> {
    // For UI: claim triggers immediate sending of verification (if timer already finished)
    // For bot deeplink: acts as "Return to Bot" — send payload to bot immediately
    if(incoming.from === 'ui'){
      // user manually claims early: only allow if timer reached 0 — otherwise ignore
      if(remaining > 0){
        // ignore claim until finished
        setStatus && setStatus('Please wait until the timer finishes to claim', true);
        return;
      }
      // otherwise finalize
      finalizeAndSend();
    } else {
      // return to bot: send result to bot and close
      finalizeAndSend({ toBot:true });
    }
  });

  closeBtn && closeBtn.addEventListener('click', ()=>{
    // close: notify parent/bot then try to self-close
    postParent({ type:'close_hosted', reason:'user_closed', payload: { id: incoming.id } });
    try{ if(window.close) window.close(); }catch(e){}
  });

  // start countdown using incoming.secs
  startCountdown(incoming.secs || 0);
}

/* ==== ad injection: AdSense + Adsterra fallback ==== */
function injectAdsIntoPlayer(){
  try{
    const holder = el('adsenseHolder');
    if(!holder) return;
    // insert AdSense ins (exact as requested)
    holder.innerHTML = `
      <!-- GainGrid_Display_Horizontal -->
      <ins class="adsbygoogle"
           style="display:inline-block;width:468px;height:60px"
           data-ad-client="ca-pub-2309008538670900"
           data-ad-slot="4194843603"></ins>
    `;
    try{ (adsbygoogle = window.adsbygoogle || []).push({}); }catch(e){ console.warn('adsbygoogle push failed', e); }

    // also attempt Adsterra banner below (kept as fallback)
    const ast = document.createElement('div');
    ast.id = 'adsterBannerHolder';
    ast.style.marginTop = '6px';
    holder.appendChild(ast);
    injectAdsterraIntoElement(ast);
  }catch(e){ console.warn('injectAdsIntoPlayer failed', e); }
}

/* ==== countdown + finalize ==== */
function startCountdown(secs){
  try{ remaining = Number(secs) || 0; }catch(e){ remaining = 0; }
  const display = el('adCount');
  if(display) display.textContent = remaining;

  if(countdownTimer) clearInterval(countdownTimer);
  // tick every second
  countdownTimer = setInterval(()=>{
    remaining--;
    if(display) display.textContent = remaining;
    if(remaining <= 0){
      clearInterval(countdownTimer);
      countdownTimer = null;
      // finalize exactly now
      finalizeAndSend();
    }
  }, 1000);
}

/* ==== finalize: send payload back to parent or bot, cleanup, close ==== */
function finalizeAndSend(opts){
  opts = opts || {};
  if(!incoming) return;
  // prepare payload with all fields
  const payload = {
    id: incoming.id,
    task_id: incoming.id, // compatibility
    ad_id: incoming.id,
    secs: incoming.secs,
    reward: incoming.reward || 0,
    base: incoming.base || 0,
    vip_bonus: incoming.vip_bonus || 0,
    vip_level: incoming.vip_level || null,
    user_id: incoming.user_id || null,
    status: 'completed',
    ts: Date.now()
  };

  // If opened from UI, send to parent via postMessage
  if(incoming.from === 'ui'){
    try{
      postParent({ type:'ad_complete', payload });
      postParent({ type:'task_complete', payload });
      postParent({ type:'task_verified', payload });
      // also request parent to close hosted iframe (parent will hide)
      setTimeout(()=> postParent({ type:'close_hosted', reason:'ad_done', payload }), 300);
    }catch(e){ console.warn('finalizeAndSend postParent failed', e); }
  } else {
    // opened from bot deeplink — reply to bot directly
    try{
      replyToBot('ad_complete', payload).catch(()=>{});
      // Also attempt to notify parent if parent exists
      postParent({ type:'ad_complete', payload });
      // close after short delay
      setTimeout(()=> { try{ if(window.close) window.close(); }catch(e){} }, 600);
    }catch(e){ console.warn('finalizeAndSend bot reply failed', e); }
  }

  // cleanup stored ad/task entry if present in localStorage (so next call can regenerate)
  try{
    const key = 'ads_data';
    const ads = JSON.parse(localStorage.getItem(key) || '[]');
    if(Array.isArray(ads) && incoming.id){
      const filtered = ads.filter(a=> (a.id || a.ad_id || a.task_id) !== incoming.id);
      localStorage.setItem(key, JSON.stringify(filtered));
    }
  }catch(e){}

  // visual feedback
  if(el('adNote')) el('adNote').textContent = 'Completed — returning...';
}

/* ==== Adsterra helpers (kept) ==== */
function injectAdsterraIntoElement(elem){
  try{
    const s1 = document.createElement('script'); s1.type='text/javascript';
    s1.text = "atOptions = { 'key' : '" + ADSTER_SCRIPT_KEY + "', 'format' : 'iframe', 'height' : 60, 'width' : 468, 'params' : {} };";
    elem.appendChild(s1);
    const s2 = document.createElement('script'); s2.type='text/javascript'; s2.src = ADSTER_SCRIPT_SRC;
    elem.appendChild(s2);
  }catch(e){ console.warn('injectAdsterraIntoElement failed', e); }
}

/* ==== Message receiver: Listen for parent postMessage (gain.web) sending ad/task details =====
   Expected shape:
     { type:'open_ad' or 'open_task' or 'start_payload', payload: { id, secs, reward, base, vip_bonus, vip_level, user_id, from:'ui' } }
*/
window.addEventListener('message', function(ev){
  try{
    const data = ev.data || {};
    if(!data || typeof data !== 'object') return;
    // optional: check ev.origin === allowed origin in production

    if(data.type === 'start_payload' && data.payload){
      incoming = Object.assign({}, data.payload);
      incoming.from = incoming.from || 'ui';
      originSource = 'ui';
      renderPlayerUsingIncoming();
      return;
    }

    // support old message types: open_ad/open_task
    if((data.type === 'open_ad' || data.type === 'open_task') && data.payload){
      incoming = Object.assign({}, data.payload);
      incoming.from = 'ui';
      originSource = 'ui';
      renderPlayerUsingIncoming();
      return;
    }

    // parent may also send profile_response – set vip label if present
    if(data.type === 'profile_response' && data.payload){ setVIPLabel(data.payload.vip_level || data.payload.vip || '—'); return; }

    // parent might request close
    if(data.type === 'request_close_from_parent' || data.type === 'close_hosted'){
      try{ if(window.close) window.close(); }catch(e){}
    }

  }catch(e){ console.warn('message handler err', e); }
}, false);

/* ==== startup: determine initial incoming (deeplink) or wait for parent ==== */
(function startup(){
  // 1) Try query/hash data (deeplink)
  const q = initIncomingFromQueryOrHash();
  if(q && (q.id || q.ad_id || q.task_id)){
    // if deeplink from bot, we may need to randomize secs/reward if not passed
    incoming = q;
    if(!incoming.secs){
      // random secs and reward only when opened by bot deeplink (user asked)
      const choices = [30,40,50,60];
      incoming.secs = choices[Math.floor(Math.random()*choices.length)];
    }
    // if reward not provided, compute base and vip bonus (local fallback when parent not present)
    if(!incoming.reward){
      const base = Math.floor(Math.random() * (120 - 60 + 1)) + 60;
      // scale by secs ratio
      incoming.base = Math.max(1, Math.floor(base * (incoming.secs/30)));
      const vipKey = (incoming.vip_level||'').toString().toLowerCase();
      incoming.vip_bonus = VIP_BONUS[vipKey] || 0;
      incoming.reward = incoming.base + incoming.vip_bonus;
    }
    originSource = 'bot';
    renderPlayerUsingIncoming();
    return;
  }

  // 2) Otherwise show idle message and wait for parent postMessage
  setMain(`<div class="small">Waiting for parent or deeplink to send ad/task details…</div>`);
})();

/* ==== Back button: try to close and notify parent/bot ==== */
el('backBtn').addEventListener('click', ()=> {
  postParent({ type:'close_hosted', reason:'user_back', payload: { id: incoming && incoming.id }});
  try{ if(window.close) window.close(); }catch(e){}
});

/* optional setStatus no-op if parent provides it */
function setStatus(){}

/* end of hosted script */
</script>
</body>
</html>