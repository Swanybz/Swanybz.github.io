<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>GainGrid Hosted — Tasks & Ads (iframe-ready)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

<!-- EXACT Google AdSense core script you provided -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2309008538670900"
     crossorigin="anonymous"></script>

<style>
  :root{
    --accent1:#ff6b9d; --accent2:#c471ed;
    --bg:linear-gradient(135deg,#0f1419 0,#1a2332 50%,#0d1117 100%);
  }
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;color:#fff;background:var(--bg)}
  .viewport-wrap{width:100%;height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
  .card{width:var(--card-width,420px);height:var(--card-height,620px);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(0,0,0,0.5);display:flex;flex-direction:column;overflow:hidden}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex:0 0 auto}
  .back-btn{background:transparent;border:0;color:rgba(255,255,255,0.9);cursor:pointer;font-weight:700}
  h2{margin:0;font-size:16px}
  .small{font-size:12px;color:rgba(255,255,255,0.78)}
  .btn{padding:8px 10px;border-radius:8px;background:linear-gradient(45deg,var(--accent1),var(--accent2));border:none;color:#fff;cursor:pointer;font-weight:700}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .content{flex:1 1 auto;overflow:hidden;display:flex;flex-direction:column}
  .task-list{display:flex;flex-direction:column;gap:10px;margin:8px 0;overflow:auto;padding-right:6px}
  .task-list::-webkit-scrollbar{width:8px}
  .task-list::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.05);border-radius:6px}
  .card-item{width:100%;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:space-between;gap:12px;min-height:56px;}
  .card-item .left{flex:1;min-width:0}
  .card-item strong{display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:14px}
  .card-item .meta{font-size:12px;color:rgba(255,255,255,0.66);margin-top:6px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .ad-player{width:100%;height:var(--ad-height,260px);border-radius:8px;overflow:hidden;background:#000;display:flex;align-items:center;justify-content:center;position:relative;margin-top:12px}
  .ad-player iframe,.ad-player video{width:100%;height:100%;border:0;object-fit:cover}
  .note{margin-top:8px;color:rgba(255,255,255,0.6);font-size:12px}
  .countdown{font-weight:700;font-size:18px;color:#fff}
  .hidden{display:none}
  #adPlayerAdsenseHolder, #taskBanner, #adsterBannerHolder{display:flex;justify-content:center;align-items:center}
  .dbg{position:absolute;left:8px;bottom:8px;padding:6px 8px;background:rgba(0,0,0,0.6);border-radius:6px;font-size:11px;color:#fff;z-index:50;display:none}
  .dbg.dbg-visible{display:block}
  .landing-buttons{display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center;margin-top:8px}
  .landing-buttons .big{padding:12px 16px;font-size:15px;border-radius:10px}
  .gaingrid-verified{color:lightgreen;margin-top:6px;font-weight:600;font-size:12px}
  /* hosted modal styles (kept minimal same as parent expects) */
  .hosted-wrap{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999}
  .hosted-card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:10px;max-width:560px;width:100%}
  .hosted-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .loader-popup{position:fixed;left:50%;top:12px;transform:translateX(-50%);background:rgba(0,0,0,0.7);padding:8px 12px;border-radius:8px;z-index:10001}
  .status-bubble{position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);padding:6px 8px;border-radius:8px;z-index:10002}
</style>
</head>
<body>
  <div class="viewport-wrap">
    <div class="card" id="root">
      <div class="topbar">
        <button id="backBtn" class="back-btn">← Back</button>
        <div style="text-align:right">
          <div class="small" id="vipInfo">VIP: —</div>
        </div>
      </div>

      <div class="content">
        <div id="main" class="small">Initializing…</div>
      </div>

      <div class="dbg" id="dbg">dbg</div>
    </div>
  </div>

  <!-- Hosted iframe modal (kept identical to parent expectation) -->
  <div id="hostedWrap" class="hosted-wrap" aria-hidden="true" style="display:none;">
    <div class="hosted-card" role="dialog" aria-modal="true" style="width:100%;max-width:560px;">
      <div class="hosted-top">
        <div class="small">Hosted view</div>
        <div>
          <button id="hostedBack" class="hosted-close btn ghost">Close</button>
        </div>
      </div>
      <iframe id="hostFrame" class="hosted-iframe" sandbox="allow-scripts allow-same-origin allow-forms allow-popups" src="about:blank" style="width:100%;height:360px;border:0;border-radius:8px;"></iframe>
    </div>
  </div>

  <!-- loader popup -->
  <div id="loaderPopup" class="loader-popup" style="display:none">Loading…</div>

  <!-- small status bubble -->
  <div id="statusBubble" class="status-bubble" style="display:none">Status</div>

<script>
/* ============================
   Hosted HTML — final integrated version
   - Dual-mode: Public demo (AdSense) + Parent (gain.web / deeplink) authoritative payloads
   - Keeps all names, IDs, UI, animation and logic names as you had them
   - Sends webhook to BOT_WEBHOOK on completion/validation
   ============================ */

/* ---------- CONFIG ---------- */
const BOT_WEBHOOK = "https://gaingrid.bots.business/onWebhook";
const HOSTED_ORIGIN = "https://swanybz.github.io/"; // parent checks use this origin (allow empty for dev)
const ADSENSE_CLIENT = "ca-pub-2309008538670900";
const HOSTED_DEBUG = true;

/* ---------- small utilities ---------- */
const el = id => document.getElementById(id);
function logd(...a){ if(HOSTED_DEBUG) console.log('[hosted]', ...a); try{ if(HOSTED_DEBUG && el('dbg')) el('dbg').textContent = Array.from(a).slice(0,2).join(' ').slice(0,40); }catch(e){} }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function randInt(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function setMain(html){ if(el('main')) el('main').innerHTML = html; }

/* ---------- storage keys ---------- */
const KEY_AUTH = 'gg_hosted_authoritative_payload';
const KEY_PROFILE = 'gg_hosted_profile';
const KEY_LAST_AD = 'gg_hosted_last_ad_payload';
const AD_DURATIONS = [30,40,50,60];

/* ---------- decode helpers (kept and robust) ---------- */
function tryDecodePayloadString(raw){
  if(!raw) return null;
  try {
    if(raw.startsWith('%7B') || raw.startsWith('%5B') || raw.indexOf('%22')!==-1){
      try{ return JSON.parse(decodeURIComponent(raw)); }catch(e){}
    }
    let norm = raw.replace(/\s+/g,'').replace(/-/g,'+').replace(/_/g,'/');
    const pad = norm.length % 4;
    if(pad === 2) norm += '=='; else if(pad === 3) norm += '=';
    let decoded = null;
    try { decoded = atob(norm); } catch(e){ decoded = null; }
    if(!decoded) try { decoded = decodeURIComponent(raw); } catch(e){ decoded = raw; }
    try { return JSON.parse(decoded); } catch(e){ return decoded; }
  } catch(err){ console.warn('tryDecodePayloadString err', err); return null; }
}

/* ---------- profile/UI helpers (kept) ---------- */
let profile = null;
function applyUserData(u){
  try {
    if(!u) return;
    profile = Object.assign({}, profile || {}, u);
    if(el('profileName')) el('profileName').textContent = u.username ? ("@" + u.username) : (u.first_name || "Guest");
    if(el('vipInfo')) el('vipInfo').textContent = u.vip_level ? ("VIP: " + u.vip_level) : 'VIP: —';
    try { sessionStorage.setItem(KEY_PROFILE, JSON.stringify(profile)); } catch(e){}
  } catch(e){ console.warn('applyUserData', e); }
}
function setVIPLabel(){ if(el('vipInfo')) el('vipInfo').textContent = (profile && profile.vip_level) ? ('VIP: ' + profile.vip_level) : 'VIP: —'; }

/* ---------- clear stored payloads ---------- */
function clearStartPayload(){
  try { sessionStorage.removeItem(KEY_AUTH); } catch(e){}
  try { sessionStorage.removeItem(KEY_PROFILE); } catch(e){}
  try { sessionStorage.removeItem(KEY_LAST_AD); } catch(e){}
  profile = null;
  try { if(el('vipInfo')) el('vipInfo').textContent = 'VIP: —'; } catch(e){}
  logd('cleared payload');
}

/* ---------- process incoming authoritative payload (central) ---------- */
function processStartPayload(payload){
  try {
    if(!payload || typeof payload !== 'object') return;
    // Save authoritative payload for later verification
    try { sessionStorage.setItem(KEY_AUTH, JSON.stringify(payload)); } catch(e){}
    // apply user/profile if present
    if(payload.user && typeof payload.user === 'object') applyUserData(payload.user);
    else if(payload.profile && typeof payload.profile === 'object') applyUserData(payload.profile);
    else if(payload.vip_level && (!profile || !profile.vip_level)){ profile = profile || {}; profile.vip_level = payload.vip_level; setVIPLabel(); }

    // If this is an ad payload -> open ad flow
    if(payload.ad_id || payload.id || payload.isAd || payload.type === 'ad'){
      const ad = {
        ad_id: payload.ad_id || payload.id,
        secs: Number(payload.secs || payload.s || payload.duration) || null,
        reward: Number(payload.reward || payload.r || payload.base) || null,
        vip_level: payload.vip_level || payload.vip || null,
        user: payload.user || payload
      };
      // store last ad payload
      try { sessionStorage.setItem(KEY_LAST_AD, JSON.stringify(ad)); } catch(e){}
      // hide public landing when authoritative
      hidePublicButtons();
      // run ad flow
      renderAdFlow({ ad_id: ad.ad_id, secs: ad.secs, reward: ad.reward, vip: ad.vip_level, user: ad.user, _source: 'parent' });
      return;
    }

    // If tasks provided -> render tasks area
    if(Array.isArray(payload.tasks) && payload.tasks.length){
      const mapped = payload.tasks.map(t => ({ id: t.id || t.task_id || ('task_' + Math.random().toString(36).slice(2,8)), title: t.title || t.name || ('Task ' + (t.id||'')), secs: t.secs || t.duration || 30, reward: t.reward || t.base || 0, url: t.url || t.link || '', tag: t.tag || t.type || '' }));
      PARENT_TASKS = mapped;
      renderTasksFromParent(PARENT_TASKS);
      hidePublicButtons();
      return;
    }

    // else: store and show message
    setMain('<div class="small">Payload received and stored. Use UI to start ad/task.</div>');
    hidePublicButtons();
  } catch(err){ console.warn('processStartPayload err', err); }
}

/* ---------- parse hash payload on boot (base64 in hash) ---------- */
(function parseHashPayloadOnBoot(){
  try {
    const h = (location.hash || '').replace(/^#/,'');
    if(!h) return;
    // ignore query-like hash (#/?a=b)
    if(h.indexOf('=') !== -1 || h.indexOf('&') !== -1 || h.indexOf('?') === 0) return;
    const decoded = tryDecodePayloadString(decodeURIComponent(h));
    if(decoded && typeof decoded === 'object'){
      processStartPayload(decoded);
    }
  } catch(e){ console.warn('parseHashPayloadOnBoot', e); }
})();

/* ---------- queued messages before ready (kept) ---------- */
window.__HOSTED_INCOMING_QUEUE = window.__HOSTED_INCOMING_QUEUE || [];
window.__HOSTED_IS_READY = false;

/* ---------- early message queue handler (keeps) ---------- */
window.addEventListener('message', function __earlyHostQueue(ev){
  try{
    const d = ev && ev.data;
    if(!d || typeof d !== 'object') return;

    if(d.type === 'ping_hosted'){
      try{ (ev.source && ev.source.postMessage) && ev.source.postMessage({ type: 'hosted_pong', payload:{ ts: Date.now() } }, '*'); }catch(e){}
      return;
    }

    if(d.type === 'start_payload' || d.type === 'open_task' || d.type === 'open_ad'){
      let normalized = { type:'start_payload', payload: {} };
      if(d.type === 'start_payload') normalized = d;
      else normalized.payload = d.payload || d;
      if(!window.__HOSTED_IS_READY){
        window.__HOSTED_INCOMING_QUEUE.push(normalized);
        try{ if(window.__hostedDebug) window.__hostedDebug('queued:'+ (normalized.payload && (normalized.payload.ad_id||normalized.payload.task_id||'p')) ); }catch(e){}
        return;
      }
      processStartPayload(normalized.payload);
      return;
    }

    if(!window.__HOSTED_IS_READY){
      window.__HOSTED_INCOMING_QUEUE.push(d);
      return;
    }

  }catch(err){ console.warn('earlyHostQueue err', err); }
}, false);

/* helper to post to parent robustly (kept) */
function postParent(msg){
  try{ if(window.parent && window.parent !== window) window.parent.postMessage(msg, '*'); }catch(e){}
  try{ if(window.opener && !window.opener.closed) window.opener.postMessage(msg, '*'); }catch(e){}
  try{ logd('postParent:', msg.type || msg); }catch(e){}
}

/* consume queued messages once ready */
function _consumeQueuedMessages(){
  try{
    while(window.__HOSTED_INCOMING_QUEUE && window.__HOSTED_INCOMING_QUEUE.length){
      const msg = window.__HOSTED_INCOMING_QUEUE.shift();
      if(!msg) continue;
      if(msg.type === 'start_payload'){
        processStartPayload(msg.payload || {});
      } else {
        try{ window.dispatchEvent(new MessageEvent('message', { data: msg })); }catch(e){}
      }
    }
  }catch(e){ console.warn('consume queue error', e); }
}

/* ===== announce ready / handshake (kept) ===== */
function announceReady(){
  try{
    window.__HOSTED_IS_READY = true;
    _consumeQueuedMessages();
    // include ad_id if present in stored authoritative payload
    let auth = null;
    try { auth = JSON.parse(sessionStorage.getItem(KEY_AUTH) || 'null'); } catch(e){ auth = null; }
    const payload = { ts: Date.now() };
    if(auth && (auth.ad_id || auth.id)) payload.ad_id = (auth.ad_id || auth.id);
    postParent({ type: 'hosted_ready', payload });
    logd('announceReady', payload);
    if(el('dbg')) el('dbg').textContent = 'hosted:ready' + (payload.ad_id ? ' ad:' + payload.ad_id : '');
  } catch(e){ console.warn('announceReady failed', e); }
}
if(document.readyState === 'complete' || document.readyState === 'interactive') setTimeout(announceReady, 60);
else document.addEventListener('DOMContentLoaded', ()=> setTimeout(announceReady, 60));

/* ---------- global message handler (main) ---------- */
window.addEventListener('message', function(ev){
  try{
    const d = ev.data || {};
    if(!d || typeof d !== 'object') return;
    try{ if(window.__hostedDebug) logd('msg', d.type); }catch(e){}

    // parent provided profile response
    if(d.type === 'profile_response' && d.payload){ applyUserData(d.payload); return; }

    // central start payload from parent
    if(d.type === 'start_payload' && d.payload){
      try { processStartPayload(d.payload); } catch(e){ console.warn('processStartPayload msg err', e); }
      return;
    }

    // open ad command
    if(d.type === 'open_ad' && d.payload && d.payload.ad_id){
      try{ sessionStorage.setItem(KEY_AUTH, JSON.stringify(d.payload)); }catch(e){}
      hidePublicButtons();
      renderAdFlow({ ad_id: d.payload.ad_id, secs: d.payload.secs, reward: d.payload.reward, vip: d.payload.vip, user: d.payload.user });
      return;
    }

    // open task command
    if(d.type === 'open_task' && d.payload && d.payload.task_id){
      try{ sessionStorage.setItem(KEY_AUTH, JSON.stringify(d.payload)); }catch(e){}
      hidePublicButtons();
      awaitRunTaskFlowFromPayload(d.payload);
      return;
    }

    // request close
    if(d.type === 'close_hosted' || d.type === 'request_close'){
      try{ if(window.close) window.close(); }catch(e){}
      return;
    }
  }catch(e){ console.warn('hosted message err', e); }
});

/* ---------- PARENT TASKS / UI (kept) ---------- */
let PARENT_TASKS = null;
function renderTasksFromParent(tasks){
  try{
    PARENT_TASKS = Array.isArray(tasks) ? tasks.slice() : [];
    if(!PARENT_TASKS.length){ setMain('<div class="small">No tasks provided by parent.</div>'); return; }
    const html = PARENT_TASKS.map(t=>`
      <div class="card-item" role="article" data-task-id="${escapeHtml(t.id)}">
        <div class="left">
          <strong>${escapeHtml(t.title||t.name||'Task')}</strong>
          <div class="meta">${escapeHtml((t.secs||30) + 's · ' + (t.reward||0) + ' G')}</div>
        </div>
        <div style="flex-shrink:0">
          <button class="btn do-task" data-id="${encodeURIComponent(t.id)}" data-url="${encodeURIComponent(t.url||'')}" data-secs="${t.secs||30}" data-reward="${t.reward||0}">Do</button>
        </div>
      </div>`).join('');
    setMain(`<div class="small">Tasks provided by parent</div><div class="task-list" id="taskList">${html}</div>`);
    // wire buttons safely
    Array.from(document.querySelectorAll('.do-task')).forEach(b=> {
      b.addEventListener('click', async ()=>{
        const id = decodeURIComponent(b.getAttribute('data-id'));
        const url = decodeURIComponent(b.getAttribute('data-url'));
        const secs = Number(b.getAttribute('data-secs')||30);
        const rewardBase = Number(b.getAttribute('data-reward')||0);
        postParent({ type:'task_started', payload:{ task_id: id, task_type: 'auto' } });
        await runTaskFlow({ task_id: id, url, secs, rewardBase, reward: rewardBase, _source: 'ui' });
      });
    });
  }catch(e){
    console.warn('renderTasksFromParent error', e);
    setMain(`<div class="small">Unable to render tasks from parent.</div>`);
  }
}
function escapeHtml(s){ if(!s && s!==0) return ''; return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ---------- small UI: public landing ---------- */
function showPublicLanding(){
  setMain(`<div style="text-align:center">
    <h2 style="margin:0 0 6px 0">GainGrid — Public Preview</h2>
    <div class="small">Open demo for AdSense & testers. Choose a section:</div>
    <div class="landing-buttons">
      <button id="landingTasks" class="btn big">🧾 Task Board</button>
      <button id="landingAds" class="btn big">🎥 Ads Center</button>
    </div>
    <div style="margin-top:12px;text-align:center">
      <div id="adPlayerAdsenseHolder" style="margin:8px auto;max-width:468px">
        <!-- Visible AdSense preview (so crawlers see ad slot) -->
        <ins class="adsbygoogle"
             style="display:inline-block;width:468px;height:60px"
             data-ad-client="${ADSENSE_CLIENT}"
             data-ad-slot="4194843603"></ins>
      </div>
      <div class="small" style="margin-top:8px">Ads preview area — GainGrid public mode</div>
    </div>
  </div>`);
  try{ (adsbygoogle = window.adsbygoogle || []).push({}); }catch(e){}
  // wire landing buttons
  setTimeout(()=>{
    const lt = el('landingTasks'), la = el('landingAds');
    if(lt) lt.addEventListener('click', ()=> { renderTaskBoard({}); });
    if(la) la.addEventListener('click', ()=> { renderAdFlow({ ad_id: 'public_demo', secs: randInt(AD_DURATIONS), reward: 0, vip: 'none', _source:'public' }); });
  },40);
}

/* ---------- TASK BOARD (kept minimal) ---------- */
async function renderTaskBoard(qp){
  setTitle('Task Board'); setVIPLabel();
  setMain('<div class="small">Loading tasks…</div>');
  const demo = [{ id:'demo_task_1', title:'Demo Task — Visit Example', secs:10, reward:0, url:'https://example.com' }, { id:'demo_task_2', title:'Demo Task — Read Help', secs:8, reward:0, url:'https://example.com' }];
  PARENT_TASKS = demo;
  renderTasksFromParent(PARENT_TASKS);
}

/* ---------- runTaskFlow (kept) ---------- */
async function awaitRunTaskFlowFromPayload(p){
  try{
    const id = p.task_id || p.id || ('task_' + Math.random().toString(36).slice(2,8));
    const secs = Number(p.secs || p.duration || 30);
    const reward = Number(p.reward || p.base || 0);
    const url = p.url || p.link || '';
    setTimeout(()=> { try{ runTaskFlow({ task_id: id, url, secs, rewardBase: reward, reward: reward, _source:'ui' }); }catch(e){ console.warn('runTaskFlow err', e); } }, 10);
  }catch(e){ console.warn('awaitRunTaskFlowFromPayload', e); }
}
async function runTaskFlow(opts){
  try{ if(typeof pushView === 'function') pushView('task'); }catch(e){}
  setTitle('Task'); setVIPLabel();
  const taskId = opts.task_id || ('task_' + Math.random().toString(36).slice(2,8));
  const secs = Number(opts.secs || 30);
  const url = opts.url || '';
  const authoritativeReward = (typeof opts.reward === 'number' && !isNaN(opts.reward)) ? Number(opts.reward) : (typeof opts.rewardBase === 'number' && !isNaN(opts.rewardBase) ? Number(opts.rewardBase) : null);

  setMain(`<div class="small">Task ${escapeHtml(taskId)} — open the target and remain for <strong>${secs}s</strong> to verify.</div>
    <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><button id="openBtn" class="btn">Open & Start</button><button id="cancelBtn" class="btn ghost">Cancel</button></div>
    <div id="taskNote" class="small" style="margin-top:12px"></div>`);
  const openBtn = el('openBtn'), cancelBtn = el('cancelBtn'), note = el('taskNote');
  let finished=false, popup=null, poll=null, expectedEnd=null, safetyTimer=null;

  function cleanup(){
    try{ if(poll) clearInterval(poll); }catch(e){} if(safetyTimer){ clearTimeout(safetyTimer); safetyTimer=null;}
    document.removeEventListener('visibilitychange', visibilityHandler);
    window.removeEventListener('focus', focusHandler);
    window.removeEventListener('message', parentVerificationListener);
  }

  async function finalizeSuccess(){
    if(finished) return;
    finished = true;
    cleanup();
    const vip = vipFrom({});
    let rewardObj;
    if(authoritativeReward !== null){
      const vipBonus = VIP_BONUS[(vip||'').toString().toLowerCase()] || 0;
      const base = Math.max(0, authoritativeReward - vipBonus);
      rewardObj = { base, vip_bonus: vipBonus, total: authoritativeReward };
    } else {
      rewardObj = calcTaskReward(vip) || { base: 0, vip_bonus: 0, total: 0 };
    }

    addTaskDone(taskId);

    const payload = {
      task_id: taskId,
      reward: rewardObj.total || (authoritativeReward || 0),
      base: rewardObj.base || (authoritativeReward || 0),
      vip_bonus: rewardObj.vip_bonus || 0,
      vip_level: vip || null,
      user_id: (profile && profile.user_id) || null,
      status: 'completed'
    };

    postParent({ type:'task_complete', payload });
    postParent({ type:'task_verified', payload });
    note.textContent = 'Task verified. Returning...';
    try{ if(typeof saveTaskState === 'function') saveTaskState({ date: nowDay(), status: 'completed' }); }catch(e){}

    try{ if(popup && !popup.closed) popup.close(); }catch(e){}
    try{
      setTimeout(()=> { postParent({ type:'close_hosted', reason:'task_done', payload }); try{ if(window.close) window.close(); }catch(e){} }, 700);
    }catch(e){}
  }

  function visibilityHandler(){
    if(document.visibilityState === 'visible' && expectedEnd && Date.now() >= expectedEnd && !finished){
      finalizeSuccess();
    }
  }
  function focusHandler(){
    if(expectedEnd && Date.now() >= expectedEnd && !finished){
      finalizeSuccess();
    }
  }
  function parentVerificationListener(ev){
    try{
      const d = ev.data || {};
      if(d && d.type === 'external_verification' && d.payload && d.payload.task_id === taskId){
        finalizeSuccess();
      }
    }catch(e){}
  }

  openBtn.addEventListener('click', async ()=>{
    cancelBtn.style.display='none';
    openBtn.disabled = true;
    note.textContent = `Opening target — please stay ${secs}s for verification...`;
    expectedEnd = Date.now() + secs*1000;
    try{ popup = window.open(url, '_blank', 'noopener'); }catch(e){ popup = null; }
    if(!popup){
      try{
        const a = document.createElement('a'); a.href = url||'#'; a.target='_blank'; a.rel='noopener noreferrer'; a.style.display='none';
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
      }catch(e){}
    }

    if(popup){
      poll = setInterval(()=> {
        try{
          if(popup.closed && !finished){
            if(Date.now() < expectedEnd){
              finished = true;
              cleanup();
              const payload = { task_id: taskId, status: 'unverified_popup_closed', reward:0, base:0, vip_bonus:0, user_id: (profile && profile.user_id) || null };
              postParent({ type:'task_complete', payload });
              note.textContent = 'Popup closed before verification. Returning...';
              setTimeout(()=> postParent({ type:'close_hosted', reason:'popup_closed', payload }), 700);
            } else {
              finalizeSuccess();
            }
          }
        }catch(e){}
      },700);
    } else {
      document.addEventListener('visibilitychange', visibilityHandler);
      window.addEventListener('focus', focusHandler);
      window.addEventListener('message', parentVerificationListener);
      safetyTimer = setTimeout(()=> { if(!finished) finalizeSuccess(); }, secs*1000 + 3000);
    }

    // safety: final guard
    setTimeout(()=> { if(!finished) finalizeSuccess(); }, secs*1000 + 8000);
  });

  cancelBtn.addEventListener('click', ()=>{
    postParent({ type:'task_skipped', payload: { task_id: taskId } });
    try{ if(typeof popView === 'function') popView(); }catch(e){}
    try{ if(typeof renderTaskBoard === 'function') renderTaskBoard({}); }catch(e){}
  });

  window.addEventListener('beforeunload', ()=> { if(!finished) postParent({ type:'task_incomplete', payload:{ task_id: taskId } }); });
}

/* ===== AD FLOW (core) — full behavior for both public & parent payloads ===== */
let adTimerInterval = null;
async function renderAdFlow(qp){
  try{
    // combine authoritative payload (session) + qp
    const auth = (function(){ try{ return JSON.parse(sessionStorage.getItem(KEY_AUTH) || 'null'); }catch(e){return null;} })();
    const combined = Object.assign({}, auth || {}, qp || {});

    // if this is public_demo mode (no parent), keep buttons visible
    const isPublic = (combined._source === 'public' || combined.ad_id === 'public_demo' || combined._source === 'ui' && !combined.user);

    // derive fields
    const ad_id = combined.ad_id || combined.id || ('host_ad_' + Date.now());
    const secs = Number(combined.secs) || Number(combined.duration) || randInt(AD_DURATIONS);
    const reward = Number(combined.reward) || Number(combined.r) || (combined.base || 0);
    const vip_level = combined.vip || combined.vip_level || (profile && profile.vip_level) || 'none';
    const user = combined.user || (profile && profile) || null;

    // store last ad payload for debug and parent handshake
    try { sessionStorage.setItem(KEY_LAST_AD, JSON.stringify({ ad_id, secs, reward, vip_level, user })); } catch(e){}

    // If authoritative (parent), hide public landing buttons so Gain.web flow is direct
    if(!isPublic) hidePublicButtons();

    // render UI
    setMain(`<div class="small">Watching: <strong>${escapeHtml(ad_id)}</strong> — Reward: <strong>${reward} G</strong><div class="small">(${secs}s · VIP ${escapeHtml(vip_level)})</div></div>
      <div style="margin-top:12px" id="adPlayerNode" class="ad-player"><div class="small">Ad player area</div></div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><div class="countdown" id="adCount">${secs}</div></div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><button id="claimBtn" class="btn" disabled>Claim</button><button id="retBtn" class="btn ghost hidden">Close</button></div>
      <div class="note" id="adNote">Auto-completes after ${secs}s</div>`);

    try{ (adsbygoogle = window.adsbygoogle || []).push({}); }catch(e){}

    // attach any provider (kept simple — public friendly)
    const container = el('adPlayerNode');
    if(container){
      container.innerHTML = '';
      // For reviewers: show a simple demo video or block
      const demo = document.createElement('div');
      demo.style.width = '100%'; demo.style.height = '100%'; demo.style.display='flex'; demo.style.alignItems='center'; demo.style.justifyContent='center';
      demo.innerHTML = `<div class="small">Ad content preview — ${secs}s</div>`;
      container.appendChild(demo);
    }

    // start countdown controlled by hosted
    if(adTimerInterval) clearInterval(adTimerInterval);
    let remaining = secs;
    const countEl = el('adCount'), claimBtn = el('claimBtn'), retBtn = el('retBtn'), adNote = el('adNote');
    if(countEl) countEl.textContent = remaining;

    // notify parent that hosted opened with ad_id
    postParent({ type:'hosted_ready', payload:{ ts: Date.now(), ad_id } });

    adTimerInterval = setInterval(async ()=>{
      try{
        remaining--;
        if(countEl) countEl.textContent = remaining;
        if(remaining <= 0){
          clearInterval(adTimerInterval);
          if(claimBtn) claimBtn.disabled = false;
          adNote.textContent = 'Ad finished. Sending result...';

          // prepare payload for parent & webhook
          const payload = {
            ad_id,
            reward,
            base: reward,
            vip_bonus: 0,
            vip_level,
            user,
            status: 'completed',
            meta: { ts: Date.now() }
          };

          // inform parent (gain.web)
          try{ postParent({ type:'ad_complete', payload }); }catch(e){ logd('postParent ad_complete fail'); }

          // send webhook to bot (ads_validate)
          try { await sendWebhook({ action:'ads_validate', payload }); } catch(e){ logd('webhook err'); }

          // clear authoritative payloads to allow next calls
          try { clearStartPayload(); } catch(e){}

          // show close/return
          if(retBtn){ retBtn.classList.remove('hidden'); retBtn.textContent = (combined._source === 'ui' ? 'Return to Game' : 'Close'); }

          // ask parent to close after short delay (parent is expected to hide modal)
          setTimeout(()=>{ postParent({ type:'close_hosted', reason:'ad_done', payload }); try{ if(isLikelyEmbedded() && window.close) window.close(); }catch(e){} }, 900);

          // if deeplink bypass (no parent) — send webhook validation-only and close window
          if(!isLikelyEmbedded() && combined._source === 'deeplink'){
            try { await sendWebhook({ action:'ads_validate', payload: Object.assign({}, payload, { note:'deeplink_bypass_no_reward' }) }); }catch(e){}
            setTimeout(()=>{ try{ window.close(); }catch(e){} }, 1000);
          }
        }
      }catch(e){ console.warn('adTimer tick err', e); }
    }, 1000);

    // claim button
    if(claimBtn) claimBtn.addEventListener('click', async ()=>{
      if(claimBtn.disabled) return;
      claimBtn.disabled = true;
      const payload = { ad_id, reward, vip_level, user, status:'claimed', ts: Date.now() };
      postParent({ type:'ad_complete', payload });
      try { await sendWebhook({ action:'ads_validate', payload }); } catch(e){}
      try { clearStartPayload(); } catch(e){}
      if(retBtn) retBtn.classList.remove('hidden');
    });

    if(retBtn) retBtn.addEventListener('click', ()=> {
      postParent({ type:'close_hosted', reason:'user_return' });
      try{ if(isLikelyEmbedded() && window.close) window.close(); }catch(e){}
    });

  }catch(err){ console.warn('renderAdFlow err', err); setMain('<div class="small">Unable to start ad view.</div>'); }
}

/* ---------- send webhook to BOT (keeps) ---------- */
async function sendWebhook(data){
  try{
    await fetch(BOT_WEBHOOK, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
      keepalive: true
    });
    logd('webhook posted', data.action || '');
  } catch(e){ console.warn('sendWebhook failed', e); }
}

/* ---------- router (hash/start param handling) ---------- */
function decodeStart(raw){
  if(!raw) return null;
  try{ const norm = raw.replace(/-/g,'+').replace(/_/g,'/'); const json = atob(norm); return JSON.parse(json); }catch(e){ try{ return JSON.parse(decodeURIComponent(raw)); }catch(e){ return null; } }
}
async function router(){
  try{
    // check start query param (deeplink-like)
    const qp = (function(){ const s = location.search.replace(/^\?/,''); const obj={}; s.split('&').filter(Boolean).forEach(p=>{ const i=p.indexOf('='); if(i<0) obj[decodeURIComponent(p)]=''; else obj[decodeURIComponent(p.slice(0,i))]=decodeURIComponent(p.slice(i+1)); }); return obj; })();
    if(qp.start){
      const decoded = decodeStart(qp.start);
      if(decoded){
        // classify deeplink vs parent
        decoded._source = 'deeplink';
        processStartPayload(decoded);
        return;
      }
    }

    // check for authoritative payload in session storage (parent pushed before navigation)
    const auth = (function(){ try{ return JSON.parse(sessionStorage.getItem(KEY_AUTH)||'null'); }catch(e){return null;} })();
    if(auth) {
      if(auth.ad_id) renderAdFlow(Object.assign({}, auth, { _source: 'parent' }));
      else if(auth.tasks) { PARENT_TASKS = auth.tasks; renderTasksFromParent(PARENT_TASKS); }
      else showPublicLanding();
      return;
    }

    // default: public landing
    showPublicLanding();
  }catch(e){ console.warn('router err', e); showPublicLanding(); }
}

/* ---------- bootstrap ---------- */
if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', router);
else router();

/* ---------- small helpers & compatibility functions used above ---------- */
function isLikelyEmbedded(){
  try{
    if(window.parent && window.parent !== window) return true;
    if(window.opener) return true;
  }catch(e){}
  return false;
}
function setTitle(t){ /* placeholder if host wants to set title in UI */ }
function nowDay(){ return new Date().toISOString().slice(0,10); }
function vipFrom(qp){ qp = qp || {}; if(qp.vip || qp.vip_level) return (qp.vip||qp.vip_level).toString(); if(profile && profile.vip_level) return profile.vip_level.toString(); try{ const local = JSON.parse(sessionStorage.getItem(KEY_PROFILE)||'null'); if(local && local.vip_level) return local.vip_level; }catch(e){} return 'None'; }

/* ---------- public helpers — keep existing names/exports ---------- */
window.__hosted_clear = clearStartPayload;
window.__hosted_process = processStartPayload;

/* ---------- debug toggle (kept) ---------- */
try{ const q = (function(){ const s = location.search.replace(/^\?/,''); const o={}; s.split('&').filter(Boolean).forEach(p=>{ const i=p.indexOf('='); if(i<0) o[decodeURIComponent(p)]=''; else o[decodeURIComponent(p.slice(0,i))]=decodeURIComponent(p.slice(i+1)); }); return o; })(); if(q.dbg === '1'){ el('dbg').classList.add('dbg-visible'); el('dbg').textContent = 'dbg on'; } }catch(e){}
  
/* ---------- helper to hide public landing buttons when parent payload present ---------- */
function hidePublicButtons(){
  try{
    // if landing elements exist, hide them to avoid UX confusion when parent controls flow
    const lt = el('landingTasks'), la = el('landingAds'), adHolder = el('adPlayerAdsenseHolder');
    if(lt) lt.style.display = 'none';
    if(la) la.style.display = 'none';
    if(adHolder) adHolder.style.display = 'none';
  }catch(e){}
}

/* ---------- Back button behavior (kept) ---------- */
try{
  const back = el('backBtn');
  if(back) back.addEventListener('click', ()=> {
    try { postParent({ type:'close_hosted', reason:'user_back' }); } catch(e){}
    try{ if(isLikelyEmbedded() && window.close) window.close(); }catch(e){}
  });
}catch(e){}

/* ---------- hosted iframe quick loader: respond to start_payload posts from parent iframe usage example ---------- */
/* If parent does iframe.contentWindow.postMessage({type:'start_payload', payload: {...}}, '*') we already handle it in message event above */

/* ---------- ensure hostedBack close exists (kept for parent) ---------- */
try{
  const hostedBackBtn = el('hostedBack');
  if(hostedBackBtn) hostedBackBtn.addEventListener('click', ()=>{
    try{ postParent({ type:'request_close_from_hosted', payload:{ ts: Date.now() } }); }catch(e){}
    try{ if(window.close) window.close(); }catch(e){}
  });
}catch(e){}

/* End of hosted HTML script */
</script>
</body>
</html>