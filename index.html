<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>GainGrid Hosted — Ads (iframe-ready)</title>

<!-- AdSense core (kept) -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2309008538670900"
     crossorigin="anonymous"></script>

<style>
  :root{
    --accent1:#ff6b9d; --accent2:#c471ed;
    --bg:linear-gradient(135deg,#0f1419 0,#1a2332 50%,#0d1117 100%);
  }
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;color:#fff;background:var(--bg)}
  .viewport-wrap{width:100%;height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
  .card{width:var(--card-width,720px);height:var(--card-height,520px);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(0,0,0,0.5);display:flex;flex-direction:column;overflow:hidden}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex:0 0 auto}
  h2{margin:0;font-size:16px}
  .small{font-size:12px;color:rgba(255,255,255,0.78)}
  .ad-player{width:100%;height:var(--ad-height,360px);border-radius:8px;overflow:hidden;background:#000;display:flex;align-items:center;justify-content:center;position:relative}
  .ad-player iframe, .ad-player video{width:100%;height:100%;border:0;object-fit:cover}
  .controls{margin-top:12px;display:flex;gap:16px;align-items:center;justify-content:center}
  .btn{padding:10px 14px;border-radius:10px;background:linear-gradient(45deg,var(--accent1),var(--accent2));border:none;color:#fff;cursor:pointer;font-weight:800;font-size:14px}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .countdown{font-weight:700;font-size:18px;color:#fff}
  .note{margin-top:8px;color:rgba(255,255,255,0.6);font-size:12px;text-align:center}
  .hidden{display:none}
  #dbg{position:absolute;right:10px;bottom:10px;padding:6px 8px;background:rgba(0,0,0,0.6);border-radius:6px;font-size:11px;color:#fff;z-index:50;display:none}

  /* ==== GainGrid gradient text logo (bold, filled with gradient colors purple-red-pink) ==== */
  .gg-logo-text {
    font-weight:900;
    font-size:18px;
    letter-spacing:0.4px;
    background: linear-gradient(90deg, #c471ed 0%, #ff6b9d 45%, #ff4d79 100%);
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    color: transparent;
    display:inline-block;
  }

  /* ==== Circular loader + progress ring ==== */
  .circle-wrap { width:88px; height:88px; display:flex;align-items:center;justify-content:center; position:relative; }
  .loader-spinner { position:absolute; width:48px; height:48px; border-radius:50%; display:flex;align-items:center;justify-content:center; }
  .spinner-dot { width:8px; height:8px; border-radius:50%; background:rgba(255,255,255,0.9); opacity:0.12; animation:spinner 900ms linear infinite; }
  .spinner-dot:nth-child(2){ animation-delay:120ms; opacity:0.22 }
  .spinner-dot:nth-child(3){ animation-delay:240ms; opacity:0.32 }
  @keyframes spinner { 0%{ transform: translateY(-8px); }50%{ transform: translateY(0px); }100%{ transform: translateY(-8px); } }

  .progress-ring { width:88px; height:88px; transform: rotate(-90deg); }
  .ring-svg { width:100%; height:100%; }
  .ring-circle-bg { stroke: rgba(255,255,255,0.06); stroke-width:8; fill:none; }
  .ring-circle { stroke-linecap: round; stroke-width:8; fill:none; stroke: url(#ringGradient); transition: stroke-dashoffset 0.25s linear; }

  .circle-number {
    position:absolute; font-weight:800; font-size:20px; pointer-events:none; color:#fff;
    text-shadow:0 1px 0 rgba(0,0,0,0.6);
  }

  /* fade-out animation for the circle when finished */
  .circle-fadeout { animation:circleOut 380ms ease forwards; }
  @keyframes circleOut { to { transform: scale(0.85); opacity:0; } }

  /* claim button pop/pulse/vibrate */
  .btn-pop {
    transform-origin:center;
    animation:popIn 420ms cubic-bezier(.2,.9,.3,1) forwards;
  }
  @keyframes popIn {
    0% { transform: scale(0.6); opacity:0 }
    60% { transform: scale(1.08); opacity:1 }
    100% { transform: scale(1); }
  }
  @keyframes pulse {
    0% { transform: translateY(0) }
    50% { transform: translateY(-4px) }
    100% { transform: translateY(0) }
  }
  .btn-pulse { animation: pulse 900ms ease-in-out infinite; }

  /* progress small text */
  .progress-text { position:absolute; left:12px; bottom:10px; font-size:11px; color:rgba(255,255,255,0.9); text-shadow:0 1px 0 rgba(0,0,0,0.6); }

  /* scoped landing styles (kept) */
  #gaingrid-adsense-landing{background:rgba(255,255,255,0.02);border-radius:8px;padding:12px;margin-bottom:10px;color:#fff}
  #gaingrid-adsense-landing h1{margin:0 0 6px;font-size:18px;line-height:1.05}
  #gaingrid-adsense-landing p{margin:6px 0;font-size:13px;color:rgba(255,255,255,0.92);max-width:880px;margin-left:auto;margin-right:auto}
  #gaingrid-adsense-landing h3{margin-top:10px;margin-bottom:6px;font-size:14px}
  #gaingrid-adsense-landing ul{list-style:none;padding:0;margin:6px 0 10px;display:inline-block;text-align:left}
  #gaingrid-adsense-landing ul li{margin:6px 0;font-size:13px}
  #gaingrid-adsense-landing .gg-cta{display:inline-block;margin-top:8px;padding:6px 12px;border-radius:8px;text-decoration:none;font-weight:700;background:linear-gradient(45deg,var(--accent1),var(--accent2));box-shadow:0 6px 16px rgba(0,0,0,0.25)}
  #gaingrid-adsense-landing[hidden]{display:block !important}
  #gaingrid-adsense-landing .wrap{max-height:110px;overflow:auto;padding-right:6px}
  @media (max-width:420px){ #gaingrid-adsense-landing h1{font-size:16px} #gaingrid-adsense-landing p{font-size:12px} }

</style>
</head>
<body>
  <div class="viewport-wrap">
    <div class="card" id="root">
      <div class="topbar">
        <div style="display:flex;align-items:center;gap:12px;">
          <!-- GainGrid gradient-filled bold text logo -->
          <div>
            <div class="gg-logo-text" aria-hidden="false">Gain-Grid</div>
          </div>
          <div class="small">Hosted view</div>
        </div>
        <div style="text-align:right">
          <div class="small" id="vipInfo">VIP: —</div>
        </div>
      </div>

      <div class="content" style="flex:1 1 auto;display:flex;flex-direction:column">
        <!-- landing -->
        <section id="gaingrid-adsense-landing" aria-labelledby="gg-title" role="region">
          <div class="wrap">
            <h1 id="gg-title">Welcome to GainGrid</h1>
            <p>GainGrid is a Telegram-integrated platform that rewards users for engaging with ads, completing tasks, and playing fun games.</p>
            <p>Earn G-Coin, upgrade to VIP, and withdraw in USD, BTC, USDT, and more.</p>
            <h3>How it Works:</h3>
            <ul>
              <li>• Watch ads and earn G-Coin</li>
              <li>• Complete daily promotional tasks</li>
              <li>• Play games and get rewarded</li>
              <li>• Withdraw your earnings easily</li>
            </ul>
            <p><strong>Connect with our Telegram bot to get started!</strong></p>
            <p><a class="gg-cta" href="#app" role="button">Open GainGrid</a></p>
          </div>
          <noscript>
            <div style="margin-top:6px;font-size:12px;color:rgba(255,255,255,0.9);">The GainGrid app runs in your browser. If you don't see the app, please enable JavaScript.</div>
          </noscript>
        </section>

        <div id="adPlayer" class="ad-player" aria-live="polite">
          <div id="adPlaceholder" class="small">Ad player area</div>

          <!-- Circular loader & ring overlay (initially hidden in public mode) -->
          <div id="circleContainer" style="position:absolute;right:18px;top:18px;display:none;z-index:60;">
            <div class="circle-wrap" id="circleWrap" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <!-- SVG ring -->
              <svg class="progress-ring" viewBox="0 0 88 88" xmlns="http://www.w3.org/2000/svg">
                <defs>
                  <linearGradient id="ringGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" stop-color="#c471ed"/>
                    <stop offset="50%" stop-color="#ff6b9d"/>
                    <stop offset="100%" stop-color="#ff4d79"/>
                  </linearGradient>
                </defs>
                <circle class="ring-circle-bg" cx="44" cy="44" r="36"></circle>
                <circle class="ring-circle" cx="44" cy="44" r="36" stroke-dasharray="226.194" stroke-dashoffset="226.194"></circle>
              </svg>

              <!-- spinner (shown briefly before countdown) -->
              <div class="loader-spinner hidden" id="loaderSpinner" aria-hidden="true">
                <div class="spinner-dot"></div>
                <div class="spinner-dot"></div>
                <div class="spinner-dot"></div>
              </div>

              <div class="circle-number" id="circleNumber">—</div>
            </div>
          </div>

          <!-- progress small text -->
          <div class="progress-text" id="progressText" style="display:none">Loading…</div>
        </div>

        <!-- Controls: hidden in public mode, visible only for deeplink payload -->
        <div id="controls" class="controls hidden" role="region" aria-label="Ad controls">
          <!-- Keep countdown element for compatibility (hidden visually because circle shows) -->
          <div class="countdown hidden" id="countdown">—</div>
          <button id="claimBtn" class="btn" disabled style="opacity:0;transform:scale(0.98);">Claim / Send Result</button>
        </div>

        <div class="note" id="note" aria-hidden="false">Waiting for deeplink or public visit...</div>
      </div>

      <div id="dbg">dbg</div>
    </div>
  </div>

<script>
/* =========================
  Hosted HTML — dual-mode (enhanced with circle loader + ad_skiped on close)
  ========================= */

/* ===== CONFIG (edit only if needed) ===== */
const BOT_WEBHOOK = "https://gaingrid.bots.business/loadweb"; // loadweb endpoint (kept)
const HOSTED_SESSION_KEY = 'gg_hosted_authoritative_payload';
const ADSTER_SCRIPT_KEY = 'a8702b8b4c48420a3815542007f1c0df';
const ADSTER_SCRIPT_SRC = "//www.highperformanceformat.com/" + ADSTER_SCRIPT_KEY + "/invoke.js";
const CUSTOM_PROVIDER_URL = "https://experiencedbat.com/dbm/F.zudZGMN/vBZ_GeUM/Jelm/9ruAZ/UjlGkpPiTuYT2/ORDok/w/NEjDU-t/Ntj/Y/4_OhTuAb2iNQixZWs/aKWn1rpydHDr0IxU";

/* ===== utilities (kept names) ===== */
const el = id => document.getElementById(id);
function dbg(msg){ try{ el('dbg').style.display='block'; el('dbg').textContent = String(msg).slice(0,140); console.log('hosted:', msg); }catch(e){} }
function nowISO(){ return (new Date()).toISOString(); }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function safeParse(s){ try{ return JSON.parse(s); }catch(e){ return null; } }

/* deterministic hash for mapping timers per user */
function simpleHashToInt(s){
  try{
    const str = String(s||'');
    let h=2166136261;
    for(let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h += (h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24); }
    return Math.abs(h);
  }catch(e){ return Math.floor(Math.random()*1000000); }
}

/* ===== decode helpers (kept) ===== */
function decodeBase64UrlSafe(raw){
  if(!raw) return null;
  try{
    let r = raw.replace(/\s+/g,'').replace(/-/g,'+').replace(/_/g,'/');
    const pad = r.length % 4;
    if(pad === 2) r += '=='; else if(pad === 3) r += '=';
    const dec = atob(r);
    try{ return JSON.parse(dec);}catch(e){ return dec; }
  }catch(e){ return null; }
}
function tryDecodePayloadString(raw){
  if(!raw) return null;
  try{
    if((raw.indexOf('%7B') === 0 || raw.indexOf('%5B') === 0) || raw.indexOf('%22') !== -1){
      try { return JSON.parse(decodeURIComponent(raw)); } catch(e){}
    }
    if(raw[0] === '{' || raw[0] === '['){
      try { return JSON.parse(raw); } catch(e){}
    }
    const maybe = decodeBase64UrlSafe(raw);
    if(maybe) return maybe;
    try{ return JSON.parse(decodeURIComponent(raw));}catch(e){}
  }catch(e){}
  return null;
}

/* ===== ad provider injection helpers (kept) ===== */
async function injectAdsense(holder){
  try{
    holder.innerHTML = '';
    const ins = document.createElement('ins');
    ins.className = 'adsbygoogle';
    ins.style.display = 'block';
    ins.style.width = '100%';
    ins.style.height = '100%';
    ins.setAttribute('data-ad-client', 'ca-pub-2309008538670900');
    ins.setAttribute('data-ad-slot', '4194843603');
    holder.appendChild(ins);
    try{ (adsbygoogle = window.adsbygoogle || []).push({}); }catch(e){}
    return true;
  }catch(e){ return false; }
}
function injectCustomProvider(holder){
  try{
    holder.innerHTML = '';
    const ifr = document.createElement('iframe');
    ifr.src = CUSTOM_PROVIDER_URL;
    ifr.style.border = '0';
    ifr.style.width = '100%';
    ifr.style.height = '100%';
    ifr.setAttribute('referrerpolicy','no-referrer');
    holder.appendChild(ifr);
    return true;
  }catch(e){ return false; }
}
function injectAdsterra(holder){
  try{
    holder.innerHTML = '';
    const wrap = document.createElement('div');
    wrap.style.width = '100%'; wrap.style.height = '100%'; wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.justifyContent='center';
    holder.appendChild(wrap);
    const s1 = document.createElement('script'); s1.type='text/javascript';
    s1.text = "atOptions = { 'key' : '" + ADSTER_SCRIPT_KEY + "', 'format' : 'iframe', 'height' : 60, 'width' : 468, 'params' : {} };";
    const s2 = document.createElement('script'); s2.type='text/javascript'; s2.src = ADSTER_SCRIPT_SRC;
    wrap.appendChild(s1); wrap.appendChild(s2);
    return true;
  }catch(e){ return false; }
}
function showFallbackVideo(holder){
  try{
    holder.innerHTML = '';
    const v = document.createElement('video');
    v.src = "https://storage.googleapis.com/interactive-media-ads/media/big_buck_bunny_trailer.mp4";
    v.autoplay = true; v.muted = true; v.playsInline = true; v.controls = false;
    v.style.width='100%'; v.style.height='100%';
    holder.appendChild(v);
    try{ v.play().catch(()=>{}); }catch(e){}
    return true;
  }catch(e){ return false; }
}

/* ===== compute secs with user mapping & ranges (kept logic, extended) ===== */
function computeSecs(authoritativePayload){
  try{
    if(authoritativePayload && authoritativePayload.secs && !isNaN(Number(authoritativePayload.secs))){
      return Number(authoritativePayload.secs);
    }
    if(authoritativePayload && authoritativePayload.secs_min && authoritativePayload.secs_max){
      const min = Number(authoritativePayload.secs_min) || 0;
      const max = Number(authoritativePayload.secs_max) || min;
      if(max <= min) return min;
      if(authoritativePayload.user && (authoritativePayload.user.user_id || authoritativePayload.user_id)){
        const uid = (authoritativePayload.user.user_id || authoritativePayload.user_id);
        const h = simpleHashToInt(uid);
        return min + (h % (max - min + 1));
      }
      return Math.floor(Math.random()*(max-min+1)) + min;
    }
    if(authoritativePayload && Array.isArray(authoritativePayload.secs_list) && authoritativePayload.secs_list.length){
      if(authoritativePayload.user && (authoritativePayload.user.user_id || authoritativePayload.user_id)){
        const uid = (authoritativePayload.user.user_id || authoritativePayload.user_id);
        const h = simpleHashToInt(uid);
        return authoritativePayload.secs_list[h % authoritativePayload.secs_list.length];
      }
      return randChoice(authoritativePayload.secs_list);
    }
    const DURS = [30,40,50,60];
    if(authoritativePayload && authoritativePayload.user && (authoritativePayload.user.user_id || authoritativePayload.user_id)){
      const uid = (authoritativePayload.user.user_id || authoritativePayload.user_id);
      const h = simpleHashToInt(uid);
      return DURS[h % DURS.length];
    }
    return randChoice(DURS);
  }catch(e){
    return 30;
  }
}

/* ===== ring/progress helpers ===== */
const ringRadius = 36;
const ringCirc = 2 * Math.PI * ringRadius; // stroke-dasharray
function setRingProgress(percent){
  try{
    const ring = document.querySelector('.ring-circle');
    if(!ring) return;
    const offset = ringCirc * (1 - (percent/100));
    ring.style.strokeDasharray = ringCirc;
    ring.style.strokeDashoffset = offset;
    const wrap = el('circleWrap');
    wrap.setAttribute('aria-valuenow', Math.round(percent));
  }catch(e){}
}

/* ===== core variables ===== */
let countdownTimer = null;
let sessionActive = false;
let sessionCompleted = false;
let sessionPayload = null;

/* ===== UI helpers ===== */
function showCircle(){ try{ el('circleContainer').style.display = 'block'; el('loaderSpinner').classList.remove('hidden'); el('progressText').style.display = 'block'; }catch(e){} }
function hideCircle(){ try{ const cw = el('circleWrap'); cw.classList.add('circle-fadeout'); setTimeout(()=>{ el('circleContainer').style.display = 'none'; cw.classList.remove('circle-fadeout'); }, 420); el('progressText').style.display = 'none'; }catch(e){} }
function showClaimButton(){ try{ const btn = el('claimBtn'); btn.style.opacity = '0'; btn.style.transform = 'scale(0.92)'; btn.disabled = false; btn.classList.add('btn-pop'); btn.classList.add('btn-pulse'); btn.style.opacity = '1'; btn.style.transform = 'scale(1)'; btn.scrollIntoView({behavior:'smooth', block:'center'}); }catch(e){} }
function hideClaimButton(){ try{ const btn = el('claimBtn'); btn.disabled = true; btn.style.opacity='0'; btn.classList.remove('btn-pulse'); }catch(e){} }

/* ===== startCountdownAndReport (integrated loader + circle + pop claim) ===== */
function startCountdownAndReport(authoritativePayload, source = 'deeplink'){
  try{
    if(!authoritativePayload || typeof authoritativePayload !== 'object') return;
    try{ sessionStorage.setItem(HOSTED_SESSION_KEY, JSON.stringify(authoritativePayload)); }catch(e){}
    sessionActive = true;
    sessionCompleted = false;
    sessionPayload = authoritativePayload;

    // determine secs via computeSecs
    const secs = Number(computeSecs(authoritativePayload)) || 30;
    const ad_id = authoritativePayload.ad_id || authoritativePayload.id || ('host_ad_' + Date.now());
    const reward = authoritativePayload.reward || authoritativePayload.r || authoritativePayload.base || 0;

    // show controls and hide default landing
    el('controls').classList.remove('hidden');
    el('gaingrid-adsense-landing').style.display = 'none';
    el('note').textContent = `Ad: ${ad_id} — preparing ${secs}s`;
    el('countdown').textContent = secs;
    el('claimBtn').disabled = true;
    hideClaimButton();

    try{ if(authoritativePayload.vip_level) el('vipInfo').textContent = 'VIP: ' + authoritativePayload.vip_level; }catch(e){}

    // show ad provider
    (async ()=>{
      const holder = el('adPlayer');
      let ok = false;
      try { ok = await injectAdsense(holder); } catch(e) { ok = false; }
      if(!ok) ok = injectCustomProvider(holder);
      if(!ok) ok = injectAdsterra(holder);
      if(!ok) showFallbackVideo(holder);
    })();

    // show circle and initial loading spinner for ~800ms, then countdown
    showCircle();
    el('loaderSpinner').classList.remove('hidden');
    el('circleNumber').textContent = ''; // while loading
    setRingProgress(0);
    el('progressText').textContent = 'Loading…';

    // brief loading before countdown
    setTimeout(()=>{
      // hide spinner and start countdown
      el('loaderSpinner').classList.add('hidden');
      let remaining = secs;
      el('circleNumber').textContent = remaining;
      setRingProgress(0);
      el('progressText').textContent = `0 / ${secs}s`;

      // cleanup any existing timer
      if(countdownTimer) clearInterval(countdownTimer);
      const startTs = Date.now();
      countdownTimer = setInterval(()=>{
        const elapsed = Math.round((Date.now() - startTs)/1000);
        const pct = Math.min(100, Math.round((elapsed / secs) * 100));
        setRingProgress(pct);
        el('progressText').textContent = `${elapsed} / ${secs}s`;

        const newRemaining = Math.max(0, secs - elapsed);
        el('circleNumber').textContent = newRemaining;
        el('countdown').textContent = newRemaining;

        if(newRemaining <= 0){
          clearInterval(countdownTimer);
          countdownTimer = null;
          sessionCompleted = true;
          sessionActive = false;
          // after countdown finishes, post automatically and show claim
          el('note').textContent = 'Countdown finished — result posted to webhook.';
          const result = {
            ad_id: ad_id,
            reward: reward,
            base: authoritativePayload.base || 0,
            vip_level: authoritativePayload.vip_level || authoritativePayload.vip || null,
            user: authoritativePayload.user || authoritativePayload.user_id || null,
            status: 'completed',
            ts: nowISO(),
            original_payload: authoritativePayload
          };
          // send automatically (do not close here; user may want to hit claim to close)
          sendToWebhook(result).then(()=>{ /* ok */ }).catch(()=>{ /* ignore */ });

          // animate circle out and show claim button
          hideCircle();
          // small delay then show claim button
          setTimeout(()=> { showClaimButton(); el('note').textContent = 'Tap Claim to confirm and close.'; }, 320);
        }
      }, 250);
    }, 700); // loader duration

    // manual claim click (existing behavior preserved)
    el('claimBtn').onclick = function(){
      if(el('claimBtn').disabled) return;
      el('claimBtn').disabled = true;
      el('claimBtn').classList.remove('btn-pulse');
      sessionCompleted = true;
      sessionActive = false;
      const result = {
        ad_id: ad_id,
        reward: reward,
        base: authoritativePayload.base || 0,
        vip_level: authoritativePayload.vip_level || authoritativePayload.vip || null,
        user: authoritativePayload.user || authoritativePayload.user_id || null,
        status: 'claimed_manual',
        ts: nowISO(),
        original_payload: authoritativePayload
      };
      // send and then close
      sendToWebhook(result).then(()=> { requestCloseHost(); }).catch(()=> { requestCloseHost(); });
    };

  }catch(e){ console.warn('startCountdownAndReport err', e); dbg('count err'); }
}

/* ===== sendToWebhook (keeps loadweb endpoint) ===== */
function sendToWebhook(data){
  return new Promise((resolve, reject) => {
    try{
      const wrapper = { action: 'ads_validate', payload: data, meta: { ts: Date.now(), host: location.href } };
      const body = JSON.stringify(wrapper);
      let sent = false;
      try{
        if(navigator.sendBeacon){
          try{
            const blob = new Blob([body], { type: 'application/json' });
            sent = navigator.sendBeacon(BOT_WEBHOOK, blob);
          }catch(be){ sent = false; }
        }
      }catch(e){ sent = false; }
      if(sent){
        dbg('webhook sent via beacon: ' + (data.status||''));
        el('note').textContent = 'Result posted to webhook.';
        resolve(true);
        return;
      }
      fetch(BOT_WEBHOOK, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: body, keepalive:true })
        .then(()=> {
          dbg('webhook sent fetch: ' + (data.status||''));
          el('note').textContent = 'Result posted to webhook.';
          resolve(true);
        }).catch((err)=>{
          dbg('webhook fetch err');
          el('note').textContent = 'Failed to post result';
          resolve(false);
        });
    }catch(e){
      console.warn('sendToWebhook err', e); dbg('webhook err'); el('note').textContent = 'Failed to post result';
      resolve(false);
    }
  });
}

/* ===== requestCloseHost: try Telegram.WebApp.close(), parent postMessage, window.close() ===== */
function requestCloseHost(){
  try{
    try{
      if(window.Telegram && Telegram.WebApp && typeof Telegram.WebApp.close === 'function'){
        try{ Telegram.WebApp.close(); return; }catch(e){}
      }
      if(window.Telegram && window.Telegram.WebApp && typeof window.Telegram.WebApp.close === 'function'){
        try{ window.Telegram.WebApp.close(); return; }catch(e){}
      }
    }catch(e){}
    try{ parent.postMessage({ type: 'close_hosted' }, '*'); }catch(e){}
    try{ window.close(); }catch(e){}
    setTimeout(()=>{ try{ parent.postMessage({ type: 'close_hosted' }, '*'); }catch(e){} try{ window.close(); }catch(e){} }, 250);
  }catch(err){ console.warn('requestCloseHost err', err); }
}

/* ===== finalizeAsSkippedIfActive: send ad_skiped (user requested exact string) ===== */
function finalizeAsSkippedIfActive(reason){
  try{
    if(!sessionActive || sessionCompleted) return;
    sessionActive = false;
    sessionCompleted = false;
    const ad_id = sessionPayload && (sessionPayload.ad_id || sessionPayload.id) ? (sessionPayload.ad_id || sessionPayload.id) : ('host_ad_' + Date.now());
    const reward = sessionPayload && (sessionPayload.reward || sessionPayload.base) ? (sessionPayload.reward || sessionPayload.base) : 0;
    const result = {
      ad_id: ad_id,
      reward: reward,
      base: sessionPayload && sessionPayload.base || 0,
      vip_level: sessionPayload && (sessionPayload.vip_level || sessionPayload.vip) || null,
      user: sessionPayload && (sessionPayload.user || sessionPayload.user_id) || null,
      status: 'ad_skiped', // per your request: send ad_skiped to loadweb
      reason: reason || 'user_navigated_or_closed',
      ts: nowISO(),
      original_payload: sessionPayload || null
    };
    // attempt to send (do not block)
    sendToWebhook(result).then(()=>{/* nothing */}).catch(()=>{/* nothing */});
  }catch(e){ console.warn('finalizeAsSkippedIfActive err', e); }
}

/* ===== lifecycle events: beforeunload / pagehide / visibilitychange -> send ad_skiped ===== */
window.addEventListener('beforeunload', function(ev){
  try{
    finalizeAsSkippedIfActive('beforeunload');
  }catch(e){}
});
window.addEventListener('pagehide', function(ev){
  try{
    finalizeAsSkippedIfActive('pagehide');
  }catch(e){}
});
document.addEventListener('visibilitychange', function(){
  try{
    if(document.visibilityState === 'hidden'){
      setTimeout(()=> {
        if(document.visibilityState === 'hidden'){
          finalizeAsSkippedIfActive('visibility_hidden');
        }
      }, 1200);
    }
  }catch(e){}
});

/* ===== postMessage listener (kept) ===== */
window.addEventListener('message', function(ev){
  try{
    const d = ev.data || {};
    if(!d || typeof d !== 'object') return;
    if(d.type === 'start_payload' && d.payload){
      const payload = d.payload;
      let obj = null;
      if(typeof payload === 'string') obj = tryDecodePayloadString(payload);
      else obj = payload;
      if(obj && typeof obj === 'object'){
        el('note').textContent = 'PostMessage payload received.';
        startCountdownAndReport(obj, 'postmessage');
      }
      return;
    }
    if(d.type === 'close_hosted'){
      try{ window.close(); }catch(e){}
      return;
    }
  }catch(e){ console.warn('message handler err', e); }
}, false);

/* ===== decode incoming payloads (query start / hash / path) (kept) ===== */
function getQueryParams(){
  const s = location.search.replace(/^\?/,''); if(!s) return {};
  return s.split('&').filter(Boolean).map(p=>{ const i=p.indexOf('='); if(i<0) return [decodeURIComponent(p),'']; return [decodeURIComponent(p.slice(0,i)), decodeURIComponent(p.slice(i+1))]; }).reduce((o,[k,v])=>{ o[k]=v; return o; }, {});
}

/* ===== boot (kept) ===== */
function boot(){
  try{
    const qp = getQueryParams();
    if(qp.start){
      const decoded = tryDecodePayloadString(qp.start);
      if(decoded && typeof decoded === 'object'){
        el('note').textContent = 'Deeplink payload received.';
        startCountdownAndReport(decoded);
        return;
      }
    }

    const hraw = (location.hash || '').replace(/^#/,'');
    if(hraw){
      if(hraw.startsWith('/')){
        const parts = hraw.split('?'); const path = parts[0].replace(/^\//,'');
        const hashQP = {};
        if(parts[1]) parts[1].split('&').forEach(p=>{ const i=p.indexOf('='); if(i>=0) hashQP[decodeURIComponent(p.slice(0,i))]=decodeURIComponent(p.slice(i+1)); else hashQP[decodeURIComponent(p)]=''; });
        if(path === 'ad' && (hashQP.ad_id || hashQP.id || hashQP.start)){
          if(hashQP.start){
            const dec = tryDecodePayloadString(hashQP.start);
            if(dec && typeof dec === 'object'){ el('note').textContent = 'Hash path payload (start) received.'; startCountdownAndReport(dec); return; }
          }
          const payload = { ad_id: hashQP.ad_id || hashQP.id, secs: hashQP.secs || hashQP.duration, reward: hashQP.reward || hashQP.base, user: { user_id: hashQP.user_id || hashQP.uid || null } };
          el('note').textContent = 'Hash path payload received.';
          startCountdownAndReport(payload);
          return;
        }
      } else {
        const decoded = tryDecodePayloadString(decodeURIComponent(hraw));
        if(decoded && typeof decoded === 'object'){
          el('note').textContent = 'Hash base64 payload received.';
          startCountdownAndReport(decoded);
          return;
        }
      }
    }

    try{
      const sess = sessionStorage.getItem(HOSTED_SESSION_KEY);
      if(sess){
        const obj = safeParse(sess);
        if(obj && typeof obj === 'object'){
          el('note').textContent = 'Resumed session (no active countdown).';
        }
      }
    }catch(e){}

    el('note').textContent = 'Public mode — ad area (no controls).';
    el('controls').classList.add('hidden');
    (async ()=>{
      const holder = el('adPlayer');
      let ok = false;
      try { ok = await injectAdsense(holder); } catch(e) { ok = false; }
      if(!ok) ok = injectCustomProvider(holder);
      if(!ok) ok = injectAdsterra(holder);
      if(!ok) showFallbackVideo(holder);
    })();

  }catch(e){ console.warn('boot err', e); dbg('boot err'); }
}

/* run */
boot();

</script>
</body>
</html>