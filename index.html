<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>GainGrid Hosted — Tasks & Ads (iframe-ready)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

<!-- EXACT Google AdSense core script you provided -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2309008538670900"
     crossorigin="anonymous"></script>

<style>
  :root{
    --accent1:#ff6b9d; --accent2:#c471ed;
    --bg:linear-gradient(135deg,#0f1419 0,#1a2332 50%,#0d1117 100%);
  }
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;color:#fff;background:var(--bg)}
  .viewport-wrap{width:100%;height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
  .card{width:var(--card-width,420px);height:var(--card-height,620px);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(0,0,0,0.5);display:flex;flex-direction:column;overflow:hidden}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex:0 0 auto}
  .back-btn{background:transparent;border:0;color:rgba(255,255,255,0.9);cursor:pointer;font-weight:700}
  h2{margin:0;font-size:16px}
  .small{font-size:12px;color:rgba(255,255,255,0.78)}
  .btn{padding:8px 10px;border-radius:8px;background:linear-gradient(45deg,var(--accent1),var(--accent2));border:none;color:#fff;cursor:pointer;font-weight:700}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .content{flex:1 1 auto;overflow:hidden;display:flex;flex-direction:column}
  .task-list{display:flex;flex-direction:column;gap:10px;margin:8px 0;overflow:auto;padding-right:6px}
  .task-list::-webkit-scrollbar{width:8px}
  .task-list::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.05);border-radius:6px}
  .card-item{width:100%;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:space-between;gap:12px;min-height:56px;}
  .card-item .left{flex:1;min-width:0}
  .card-item strong{display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:14px}
  .card-item .meta{font-size:12px;color:rgba(255,255,255,0.66);margin-top:6px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .ad-player{width:100%;height:var(--ad-height,260px);border-radius:8px;overflow:hidden;background:#000;display:flex;align-items:center;justify-content:center;position:relative;margin-top:12px}
  .ad-player iframe,.ad-player video{width:100%;height:100%;border:0;object-fit:cover}
  .note{margin-top:8px;color:rgba(255,255,255,0.6);font-size:12px}
  .countdown{font-weight:700;font-size:18px;color:#fff}
  .hidden{display:none}
  #adPlayerAdsenseHolder, #taskBanner, #adsterBannerHolder{display:flex;justify-content:center;align-items:center}
  .dbg{position:absolute;left:8px;bottom:8px;padding:6px 8px;background:rgba(0,0,0,0.6);border-radius:6px;font-size:11px;color:#fff;z-index:50;display:none}
  .dbg.dbg-visible{display:block}
  .gaingrid-verified{color:lightgreen;margin-top:6px;font-weight:600;font-size:12px}
</style>
</head>
<body>
  <div class="viewport-wrap">
    <div class="card" id="root">
      <div class="topbar">
        <button id="backBtn" class="back-btn">← Back</button>
        <div style="text-align:right">
          <div class="small" id="vipInfo">VIP: —</div>
        </div>
      </div>

      <div class="content">
        <div id="main" class="small">Initializing…</div>
      </div>

      <div class="dbg" id="dbg">dbg</div>
    </div>
  </div>

<script>
/* ============================
   FULL HOSTED HTML (final)
   - Early message queue & safe processing (ADDED)
   - Authoritative parent payload handling (tasks & ads)
   - Randomized daily ads (30/40/50/60) + VIP rewards
   - AdSense + Adsterra injection (kept)
   - Preserves all original names, UI, logic
   ============================ */

/* ===== EARLY QUEUE: make sure we never drop a start_payload ===== */
/* ADDED */
window.__HOSTED_INCOMING_QUEUE = window.__HOSTED_INCOMING_QUEUE || [];
window.__HOSTED_IS_READY = false;

window.addEventListener('message', function __earlyHostQueue(ev){
  try{
    const d = ev && ev.data;
    if(!d || typeof d !== 'object') return;

    // quick ping reply
    if(d.type === 'ping_hosted'){
      try{ (ev.source && ev.source.postMessage) && ev.source.postMessage({ type: 'hosted_pong', payload:{ ts: Date.now() } }, '*'); }catch(e){}
      return;
    }

    if(d.type === 'start_payload' || d.type === 'open_task' || d.type === 'open_ad'){
      // normalize
      let normalized = { type:'start_payload', payload: {} };
      if(d.type === 'start_payload'){ normalized = d; }
      else { normalized.payload = d.payload || d; }

      if(!window.__HOSTED_IS_READY){
        window.__HOSTED_INCOMING_QUEUE.push(normalized);
        try{ if(window.__hostedDebug) window.__hostedDebug('queued:'+ (normalized.payload && (normalized.payload.id||normalized.payload.task_id||'p')) ); }catch(e){}
        return;
      }

      // ready -> process immediately
      processStartPayload(normalized.payload);
      return;
    }

    // queue other object messages when not ready
    if(!window.__HOSTED_IS_READY){
      window.__HOSTED_INCOMING_QUEUE.push(d);
      return;
    }

  }catch(err){ console.warn('earlyHostQueue err', err); }
}, false);

/* helper to post to parent robustly (kept) */
function postParent(msg){
  try{ if(window.parent && window.parent !== window) window.parent.postMessage(msg, '*'); }catch(e){}
  try{ if(window.opener && !window.opener.closed) window.opener.postMessage(msg, '*'); }catch(e){}
  try{ console.log('postParent:', msg); }catch(e){}
}

/* process start payloads into existing handlers (ADDED) */
function processStartPayload(p){
  try{
    if(!p) return;
    // tasks array
    if(Array.isArray(p.tasks) && p.tasks.length){
      PARENT_TASKS = (p.tasks||[]).map(t=>Object.assign({}, t));
      if(typeof renderTasksFromParent === 'function') renderTasksFromParent(PARENT_TASKS);
      return;
    }
    // ad
    if(p.ad_id || p.type === 'ad' || p.isAd){
      if(typeof renderAdFlow === 'function'){
        renderAdFlow({ ad_id: p.ad_id || p.id, secs: p.secs, reward: p.reward, vip: p.vip || p.vip_level });
        return;
      }
      try{ location.hash = '#/ad?id='+encodeURIComponent(p.ad_id||p.id||'')+'&secs='+encodeURIComponent(p.secs||'')+'&reward='+encodeURIComponent(p.reward||''); if(typeof router==='function') router(); }catch(e){}
      return;
    }
    // task
    if(p.task_id || p.type === 'task' || p.isTask || p.id){
      if(typeof awaitRunTaskFlowFromPayload === 'function'){
        awaitRunTaskFlowFromPayload(p);
        return;
      }
      PARENT_TASKS = PARENT_TASKS || [];
      PARENT_TASKS.unshift(p);
      if(typeof renderTasksFromParent === 'function') renderTasksFromParent(PARENT_TASKS);
      return;
    }

    // fallback: push into PARENT_TASKS if looks like a task
    if(p.id && p.title){
      PARENT_TASKS = PARENT_TASKS || [];
      PARENT_TASKS.unshift(p);
      if(typeof renderTasksFromParent === 'function') renderTasksFromParent(PARENT_TASKS);
    }
  }catch(e){ console.warn('processStartPayload error', e); }
}

/* consume queued messages once ready (ADDED) */
function _consumeQueuedMessages(){
  try{
    while(window.__HOSTED_INCOMING_QUEUE && window.__HOSTED_INCOMING_QUEUE.length){
      const msg = window.__HOSTED_INCOMING_QUEUE.shift();
      if(!msg) continue;
      if(msg.type === 'start_payload'){
        processStartPayload(msg.payload || {});
      } else {
        try{ window.dispatchEvent(new MessageEvent('message', { data: msg })); }catch(e){}
      }
    }
  }catch(e){ console.warn('consume queue error', e); }
}

/* ===== CONFIG & constants (kept names) ===== */
const ADS_LIMIT = 20;
const ADS_COOLDOWN_MS = 2 * 60 * 1000;
const TASKS_LIMIT = 7;
const VIP_BONUS = { basic:20, silver:40, gold:60, premium:100 };

const ADSTER_SCRIPT_KEY = 'a8702b8b4c48420a3815542007f1c0df';
const ADSTER_SCRIPT_SRC = "//www.highperformanceformat.com/" + ADSTER_SCRIPT_KEY + "/invoke.js";
const ADSTERRA_ZONE_URL = "https://adsterra.com/video-ad/?zone=REPLACE_WITH_YOUR_ZONE";
const GOOGLE_FALLBACK_VIDEO = "https://storage.googleapis.com/interactive-media-ads/media/big_buck_bunny_trailer.mp4";

// persistence keys
const KEY_DAY = 'gg_hosted_day';
const KEY_WATCHED = 'gg_hosted_watched_ads';
const KEY_ADS_DATA = 'ads_data';
const KEY_ADS_DATE = 'ads_date';
const KEY_TASKS = 'gg_hosted_tasks_done';
const KEY_LAST_AD = 'gg_hosted_last_ad';

/* ===== helpers ===== */
const el = id => document.getElementById(id);
function nowDay(){ return new Date().toISOString().slice(0,10); }
function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function escapeHtml(s){ if(!s && s !== 0) return ''; return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ===== small layout sizing to fit iframe phone frame ===== */
function setCardSizing(){
  const vw = Math.max(320, Math.min(window.innerWidth, 920));
  const vh = Math.max(480, Math.min(window.innerHeight, 1200));
  const cardW = Math.round(Math.min( (vw - 24), 420 ));
  const cardH = Math.round(Math.min( (vh - 80), 700 ));
  document.documentElement.style.setProperty('--card-width', cardW + 'px');
  document.documentElement.style.setProperty('--card-height', cardH + 'px');
  const adH = Math.max(120, Math.min(260, Math.round(cardH * 0.36)));
  document.documentElement.style.setProperty('--ad-height', adH + 'px');
}
setCardSizing(); window.addEventListener('resize', setCardSizing);

/* ===== storage helpers & day reset ===== */
(function ensureDayReset(){
  const d = localStorage.getItem(KEY_DAY);
  if(d !== nowDay()){
    localStorage.setItem(KEY_DAY, nowDay());
    localStorage.removeItem(KEY_WATCHED);
    localStorage.removeItem(KEY_TASKS);
    localStorage.removeItem(KEY_LAST_AD);
    localStorage.removeItem(KEY_ADS_DATA);
    localStorage.removeItem(KEY_ADS_DATE);
  }
})();

function getWatched(){ try{ return JSON.parse(localStorage.getItem(KEY_WATCHED)||'[]'); }catch(e){ return []; } }
function addWatched(id){ const a = getWatched(); if(!a.includes(id)){ a.push(id); localStorage.setItem(KEY_WATCHED, JSON.stringify(a)); } }
function getTasksDone(){ try{ return JSON.parse(localStorage.getItem(KEY_TASKS)||'[]'); }catch(e){ return []; } }
function addTaskDone(id){ const a = getTasksDone(); if(!a.includes(id)){ a.push(id); localStorage.setItem(KEY_TASKS, JSON.stringify(a)); } }
function setLastAdTs(ts){ localStorage.setItem(KEY_LAST_AD, String(ts)); }
function getLastAdTs(){ return Number(localStorage.getItem(KEY_LAST_AD) || 0); }
function canOpenAdNow(){ const last = getLastAdTs(); if(!last) return true; return (Date.now() - last) >= ADS_COOLDOWN_MS; }

/* ===== read query/hash params (parent may pass id, secs, reward, vip) ===== */
function qsParse(s){ if(!s) return {}; return s.replace(/^\?/,'').split('&').filter(Boolean).reduce((o,p)=>{ const i=p.indexOf('='); if(i<0) o[decodeURIComponent(p)]=''; else o[decodeURIComponent(p.slice(0,i))]=decodeURIComponent(p.slice(i+1)); return o; }, {}); }
function getHashQP(){ if(!location.hash) return {}; const h = location.hash.replace(/^#/,''); const parts = h.split('?'); return qsParse(parts[1]||''); }
function getSearchQP(){ return qsParse(location.search || ''); }
function combinedQP(){ return Object.assign({}, getHashQP(), getSearchQP()); }

/* ===== VIP resolution & reward calcs (kept names) ===== */
let profile = null;
function readLocalProfile(){
  const keys = ['user_data','gg_user','profile','user'];
  for(const k of keys){
    try{
      const raw = localStorage.getItem(k);
      if(!raw) continue;
      const obj = JSON.parse(raw);
      if(obj && typeof obj === 'object') return obj;
    }catch(e){}
  }
  return null;
}
function vipFrom(qp){ qp = qp || {}; if(qp.vip || qp.vip_level) return (qp.vip||qp.vip_level).toString(); if(profile && profile.vip_level) return profile.vip_level.toString(); const local = readLocalProfile(); if(local && local.vip_level) return local.vip_level; return 'None'; }
function calcTaskReward(vip){ const base = rand(100, 300); const bonus = VIP_BONUS[(vip||'').toString().toLowerCase()] || 0; return { base, vip_bonus: bonus, total: base + bonus }; }
function calcAdRewardFromBase(base, vip){ const bonus = VIP_BONUS[(vip||'').toString().toLowerCase()] || 0; return { base, vip_bonus: bonus, total: base + bonus }; }

/* ===== provider helpers (ad) ===== */
function tryLoadAdsterra(zoneUrl, timeoutMs=3500){
  return new Promise((resolve) => {
    if(!zoneUrl || zoneUrl.includes('REPLACE_WITH_YOUR_ZONE')) return resolve({ ok:false });
    const iframe = document.createElement('iframe');
    iframe.src = zoneUrl;
    iframe.width = '100%'; iframe.height = '260'; iframe.style.border='0';
    let done=false;
    iframe.addEventListener('load', ()=>{ if(!done){ done=true; resolve({ ok:true, type:'adsterra', node:iframe }); }});
    iframe.addEventListener('error', ()=>{ if(!done){ done=true; resolve({ ok:false }); }});
    setTimeout(()=>{ if(!done){ done=true; resolve({ ok:false }); } }, timeoutMs);
  });
}
function tryLoadVideoSrc(videoUrl, timeoutMs=3000){
  return new Promise((resolve)=>{
    if(!videoUrl) return resolve({ ok:false });
    const video = document.createElement('video');
    video.src = videoUrl; video.controls=false; video.autoplay=true; video.muted=true; video.playsInline=true;
    let ok=false;
    function cleanup(){ video.oncanplay=null; video.onerror=null; try{ video.pause(); }catch(e){} }
    video.oncanplay = ()=>{ if(!ok){ ok=true; cleanup(); resolve({ ok:true, type:'video', node:video }); } };
    video.onerror = ()=>{ if(!ok){ ok=true; cleanup(); resolve({ ok:false }); } };
    setTimeout(()=>{ if(!ok){ ok=true; cleanup(); resolve({ ok:false }); } }, timeoutMs);
  });
}

/* ===== HOSTED: readiness handshake + debug overlay (kept & improved) ===== */
(function hostedReadyAndDebug(){
  try{
    if(!document.getElementById('hostedDbg')){
      const dbg = document.createElement('div');
      dbg.id = 'hostedDbg';
      dbg.style.position = 'absolute';
      dbg.style.right = '10px';
      dbg.style.bottom = '10px';
      dbg.style.zIndex = '9999';
      dbg.style.padding = '6px 8px';
      dbg.style.background = 'rgba(0,0,0,0.6)';
      dbg.style.color = '#fff';
      dbg.style.fontSize = '12px';
      dbg.style.borderRadius = '6px';
      dbg.style.pointerEvents = 'none';
      dbg.textContent = 'hosted:init';
      document.body.appendChild(dbg);
    }

    function announceReady(){
      try{
        // mark hosted side ready and flush queue (ADDED)
        window.__HOSTED_IS_READY = true;
        _consumeQueuedMessages(); // ADDED

        postParent({ type: 'hosted_ready', payload: { ts: Date.now() } });
        const d = document.getElementById('hostedDbg');
        if(d) d.textContent = 'hosted:ready';
      }catch(e){ console.warn('announceReady failed', e); }
    }

    if(document.readyState === 'complete' || document.readyState === 'interactive'){
      setTimeout(announceReady, 80);
    } else {
      document.addEventListener('DOMContentLoaded', ()=> setTimeout(announceReady, 80));
    }

    window.__hostedDebug = function(msg){
      try{
        const d = document.getElementById('hostedDbg');
        if(d) d.textContent = 'hosted:' + (msg || '').toString().slice(0,30);
        console.log('hostedDbg:', msg);
      }catch(e){}
    };
  }catch(e){ console.warn('hostedReadyAndDebug init error', e); }
})();

/* ===== Ads generator: create daily ads with random secs, base scaled by time + vip ===== */
function generateDailyAds(){
  try {
    const today = new Date().toDateString();
    const savedDate = localStorage.getItem(KEY_ADS_DATE);
    let savedAds = JSON.parse(localStorage.getItem(KEY_ADS_DATA) || "[]");

    if(savedDate === today && Array.isArray(savedAds) && savedAds.length > 0){
      savedAds = savedAds.filter(a => !getWatched().includes(a.id));
      localStorage.setItem(KEY_ADS_DATA, JSON.stringify(savedAds));
      if(typeof setAds === 'function') setAds(savedAds);
      return;
    }

    const AD_DURATIONS = [30,40,50,60];
    const adsList = Array.from({ length: ADS_LIMIT }).map((_, i) => {
      const secs = AD_DURATIONS[Math.floor(Math.random() * AD_DURATIONS.length)];
      const baseRand = Math.floor(Math.random() * (120 - 60 + 1)) + 60;
      const baseScaled = Math.max(1, Math.floor(baseRand * (secs/30)));
      const vipLevel = (profile && profile.vip_level) ? profile.vip_level : (readLocalProfile() && readLocalProfile().vip_level) || 'none';
      const vipBonus = (VIP_BONUS && VIP_BONUS[vipLevel?.toString().toLowerCase()]) ? VIP_BONUS[vipLevel?.toString().toLowerCase()] : 0;
      const totalReward = baseScaled + vipBonus;
      return {
        id: "auto_ad_" + (i + 1),
        title: "Watch Ad #" + (i + 1),
        desc: "Watch to earn G-Coins",
        reward: totalReward,
        base: baseScaled,
        vip_bonus: vipBonus,
        secs: secs
      };
    });

    const filtered = adsList.filter(a => !getWatched().includes(a.id));
    localStorage.setItem(KEY_ADS_DATA, JSON.stringify(filtered));
    localStorage.setItem(KEY_ADS_DATE, today);
    if(typeof setAds === 'function') setAds(filtered);
  } catch(e){ console.warn("generateDailyAds err", e); }
}

/* ===== PARENT_TASKS store & renderer (ADDED) ===== */
let PARENT_TASKS = null; // authoritative tasks array when parent sends tasks
function renderTasksFromParent(tasks){
  try{
    PARENT_TASKS = Array.isArray(tasks) ? tasks.slice() : [];
    if(!PARENT_TASKS.length){
      setMain(`<div class="small">No tasks provided by parent.</div>`);
      return;
    }
    const html = PARENT_TASKS.map(t=>{
      const id = t.id || t.task_id || ('task_' + Math.random().toString(36).slice(2,8));
      const title = escapeHtml(t.title || t.name || ('Task ' + id));
      const meta = escapeHtml((t.tag||'') + (t.secs ? (' · stay ' + t.secs + 's') : '') + (t.reward ? (' · Reward ' + t.reward + ' G') : ''));
      const urlEnc = encodeURIComponent(t.url || t.link || '');
      const idEnc = encodeURIComponent(id);
      const secs = Number(t.secs || 30);
      const reward = Number(t.reward || t.base || 0);
      return `<div class="card-item" role="article" data-task-id="${id}">
        <div class="left">
          <strong>${title}</strong>
          <div class="meta">${meta}</div>
        </div>
        <div style="flex-shrink:0">
          <button class="btn do-task" data-id="${idEnc}" data-url="${urlEnc}" data-secs="${secs}" data-reward="${reward}">Do</button>
        </div>
      </div>`;
    }).join('');

    setMain(`<div class="small">Tasks provided by parent (max ${TASKS_LIMIT}/day). Tap a task to start.</div><div class="task-list" id="taskList">${html}</div><div style="margin-top:10px;text-align:center"><div id="taskBanner"></div></div>`);
    injectAdsterraInto('taskBanner');

    // wire buttons (safe)
    Array.from(document.querySelectorAll('.do-task')).forEach(b=> b.replaceWith(b.cloneNode(true)));
    Array.from(document.querySelectorAll('.do-task')).forEach(b=>{
      b.addEventListener('click', async ()=>{
        const id = decodeURIComponent(b.getAttribute('data-id'));
        const url = decodeURIComponent(b.getAttribute('data-url'));
        const secs = Number(b.getAttribute('data-secs')||30);
        const rewardBase = Number(b.getAttribute('data-reward')||0);
        postParent({ type:'task_started', payload:{ task_id: id, task_type: 'auto' } });
        // call existing runTaskFlow with authoritative values
        await runTaskFlow({ task_id: id, url, secs, rewardBase, reward: rewardBase, _source: 'ui' });
      });
    });
  }catch(e){
    console.warn('renderTasksFromParent error', e);
    setMain(`<div class="small">Unable to render tasks from parent.</div>`);
  }
}

/* ===== UI helpers (kept) ===== */
function setMain(html){ if(el('main')) el('main').innerHTML = html; }
function setTitle(t){ if(el('hostTitle')) el('hostTitle').textContent = t || 'Hosted view'; }
function setVIPLabel(){ const qp = combinedQP(); const vip = (qp.vip || qp.vip_level) || (profile && profile.vip_level) || (readLocalProfile() && readLocalProfile().vip_level) || ''; if(el('vipInfo')) el('vipInfo').textContent = vip ? ('VIP: ' + vip) : 'VIP: —'; }

/* render task board (kept; prefer PARENT_TASKS if present) */
async function renderTaskBoard(qp){
  setTitle('Task Board'); setVIPLabel();
  if(PARENT_TASKS && Array.isArray(PARENT_TASKS) && PARENT_TASKS.length){
    renderTasksFromParent(PARENT_TASKS);
    return;
  }
  const done = getTasksDone();
  if(done.length >= TASKS_LIMIT){ setMain(`<div class="small">You have completed today's tasks. New tasks will appear tomorrow.</div>`); return; }
  setMain(`<div class="small">Loading tasks…</div>`);
  if(typeof fetchTasks === 'function'){
    const tasks = await fetchTasks(TASKS_LIMIT);
    if(!tasks || !tasks.length){ setMain(`<div class="small">No tasks available right now. Try again later.</div>`); return; }
    const html = tasks.map(t=>`
      <div class="card-item" role="article" aria-label="${escapeHtml(t.title)}">
        <div class="left">
          <strong>${escapeHtml(t.title)}</strong>
          <div class="meta">${escapeHtml(t.source||'')} · stay ${t.secs || 30}s · Reward ${t.reward || 0} G</div>
        </div>
        <div style="flex-shrink:0">
          <button class="btn do-task" data-id="${encodeURIComponent(t.id)}" data-url="${encodeURIComponent(t.url||'')}" data-secs="${t.secs||30}" data-reward="${t.reward||0}">Do</button>
        </div>
      </div>
    `).join('');
    setMain(`<div class="small">Tasks auto-generated (max ${TASKS_LIMIT}/day). Tap a task to start.</div><div class="task-list" id="taskList">${html}</div><div style="margin-top:10px;text-align:center"><div id="taskBanner"></div></div>`);
    injectAdsterraInto('taskBanner');
    Array.from(document.querySelectorAll('.do-task')).forEach(b=>{
      b.addEventListener('click', async ()=>{
        const id = decodeURIComponent(b.getAttribute('data-id'));
        const url = decodeURIComponent(b.getAttribute('data-url'));
        const secs = Number(b.getAttribute('data-secs')||30);
        const rewardBase = Number(b.getAttribute('data-reward')||120);
        postParent({ type:'task_started', payload:{ task_id: id, task_type: 'auto' } });
        await runTaskFlow({ task_id: id, url, secs, rewardBase, reward: rewardBase, _source: 'ui' });
      });
    });
  }else{
    setMain(`<div class="small">No task fetcher available.</div>`);
  }
}

/* ===== RUN TASK FLOW (uses secs/reward passed by UI if present) ===== */
async function runTaskFlow(opts){
  // FIX: guard calls to pushView/popView etc. (don't assume they exist)
  try{ if(typeof pushView === 'function') pushView('task'); }catch(e){}
  setTitle('Task'); setVIPLabel();
  const taskId = opts.task_id || ('task_' + Math.random().toString(36).slice(2,8));
  const secs = Number(opts.secs || 30);
  const url = opts.url || '';
  const authoritativeReward = (typeof opts.reward === 'number' && !isNaN(opts.reward)) ? Number(opts.reward) : (typeof opts.rewardBase === 'number' && !isNaN(opts.rewardBase) ? Number(opts.rewardBase) : null);

  setMain(`<div class="small">Task ${escapeHtml(taskId)} — open the target and remain for <strong>${secs}s</strong> to verify.</div>
    <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><button id="openBtn" class="btn">Open & Start</button><button id="cancelBtn" class="btn ghost">Cancel</button></div>
    <div id="taskNote" class="small" style="margin-top:12px"></div>`);
  const openBtn = el('openBtn'), cancelBtn = el('cancelBtn'), note = el('taskNote');
  let finished=false, popup=null, poll=null, expectedEnd=null, safetyTimer=null;

  function cleanup(){
    try{ if(poll) clearInterval(poll); }catch(e){} if(safetyTimer){ clearTimeout(safetyTimer); safetyTimer=null;}
    document.removeEventListener('visibilitychange', visibilityHandler);
    window.removeEventListener('focus', focusHandler);
    window.removeEventListener('message', parentVerificationListener);
  }

  async function finalizeSuccess(){
    if(finished) return;
    finished = true;
    cleanup();
    const vip = vipFrom({});
    // prefer authoritative reward provided by parent; otherwise fallback to calcTaskReward
    let rewardObj;
    if(authoritativeReward !== null){
      const vipBonus = VIP_BONUS[(vip||'').toString().toLowerCase()] || 0;
      const base = Math.max(0, authoritativeReward - vipBonus);
      rewardObj = { base, vip_bonus: vipBonus, total: authoritativeReward };
    } else {
      rewardObj = calcTaskReward(vip) || { base: 0, vip_bonus: 0, total: 0 };
    }

    addTaskDone(taskId);

    const payload = {
      task_id: taskId,
      reward: rewardObj.total || (authoritativeReward || 0),
      base: rewardObj.base || (authoritativeReward || 0),
      vip_bonus: rewardObj.vip_bonus || 0,
      vip_level: vip || null,
      user_id: (profile && profile.user_id) || null,
      status: 'completed'
    };

    postParent({ type:'task_complete', payload });
    postParent({ type:'task_verified', payload });
    note.textContent = 'Task verified. Returning...';
    try{ if(typeof saveTaskState === 'function') saveTaskState({ date: nowDay(), status: 'completed' }); }catch(e){}

    // Close popup if open and cleanup parent tasks
    try{ if(popup && !popup.closed) popup.close(); }catch(e){}
    try{
      if(PARENT_TASKS && Array.isArray(PARENT_TASKS)){
        PARENT_TASKS = PARENT_TASKS.filter(t => (t.id || t.task_id) !== taskId);
        const elList = document.getElementById('taskList');
        if(elList){
          Array.from(elList.querySelectorAll('.card-item')).forEach(c => {
            if((c.getAttribute('data-task-id')||'') === taskId) c.remove();
          });
        }
      }
      let tasksLocal = JSON.parse(localStorage.getItem('gg_hosted_tasks') || '[]');
      tasksLocal = (tasksLocal||[]).filter(t => (t.id || t.task_id) !== taskId);
      localStorage.setItem('gg_hosted_tasks', JSON.stringify(tasksLocal));
    }catch(e){ console.warn('cleanup PARENT_TASKS error', e); }

    setTimeout(()=> { postParent({ type:'close_hosted', reason:'task_done', payload }); try{ if(window.close) window.close(); }catch(e){} }, 700);
  }

  function visibilityHandler(){
    if(document.visibilityState === 'visible' && expectedEnd && Date.now() >= expectedEnd && !finished){
      finalizeSuccess();
    }
  }
  function focusHandler(){
    if(expectedEnd && Date.now() >= expectedEnd && !finished){
      finalizeSuccess();
    }
  }
  function parentVerificationListener(ev){
    try{
      const d = ev.data || {};
      if(d && d.type === 'external_verification' && d.payload && d.payload.task_id === taskId){
        finalizeSuccess();
      }
    }catch(e){}
  }

  openBtn.addEventListener('click', async ()=>{
    cancelBtn.style.display='none';
    openBtn.disabled = true;
    note.textContent = `Opening target — please stay ${secs}s for verification...`;
    expectedEnd = Date.now() + secs*1000;
    try{ popup = window.open(url, '_blank', 'noopener'); }catch(e){ popup = null; }
    if(!popup){
      try{
        const a = document.createElement('a'); a.href = url||'#'; a.target='_blank'; a.rel='noopener noreferrer'; a.style.display='none';
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
      }catch(e){}
    }

    if(popup){
      poll = setInterval(()=> {
        try{
          if(popup.closed && !finished){
            if(Date.now() < expectedEnd){
              finished = true;
              cleanup();
              const payload = { task_id: taskId, status: 'unverified_popup_closed', reward:0, base:0, vip_bonus:0, user_id: (profile && profile.user_id) || null };
              postParent({ type:'task_complete', payload });
              try{ if(typeof saveTaskState === 'function') saveTaskState({ date: nowDay(), status: 'idle' }); }catch(e){}
              note.textContent = 'Popup closed before verification. Returning...';
              setTimeout(()=> postParent({ type:'close_hosted', reason:'popup_closed', payload }), 700);
            } else {
              finalizeSuccess();
            }
          }
        }catch(e){}
      },700);
    } else {
      document.addEventListener('visibilitychange', visibilityHandler);
      window.addEventListener('focus', focusHandler);
      window.addEventListener('message', parentVerificationListener);
      safetyTimer = setTimeout(()=> { if(!finished) finalizeSuccess(); }, secs*1000 + 3000);
    }

    // safety: final guard
    setTimeout(()=> { if(!finished) finalizeSuccess(); }, secs*1000 + 8000);
  });

  cancelBtn.addEventListener('click', ()=>{
    postParent({ type:'task_skipped', payload: { task_id: taskId } });
    try{ if(typeof popView === 'function') popView(); }catch(e){}
    try{ if(typeof renderTaskBoard === 'function') renderTaskBoard({}); }catch(e){}
  });

  window.addEventListener('beforeunload', ()=> { if(!finished) postParent({ type:'task_incomplete', payload:{ task_id: taskId } }); });
}

/* ===== AD FLOW: prefers authoritative secs/reward from qp when passed (kept) ===== */
async function renderAdFlow(qp){
  try{ if(typeof pushView === 'function') pushView('ad'); }catch(e){}
  setTitle('Watch Ad'); setVIPLabel();

  const qpCombined = qp || combinedQP();

  const passedAdId = qpCombined.ad_id || qpCombined.id || qpCombined.ad || null;
  const passedSecs = Number(qpCombined.secs || qpCombined.s || qpCombined.duration || 0) || null;
  const passedReward = Number(qpCombined.reward || qpCombined.r || 0) || null;
  const passedVip = qpCombined.vip || qpCombined.vip_level || null;

  const watched = getWatched();
  if(watched.length >= ADS_LIMIT){
    const now = new Date(), tom = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);
    const msLeft = tom - now; const hrs = Math.floor(msLeft/3600000); const mins = Math.floor((msLeft%3600000)/60000);
    setMain(`<div class="small">Daily ad limit reached. Next ads unlock in ${hrs}h ${mins}m</div>`); currentView='ad'; return;
  }
  if(!canOpenAdNow()){
    const rem = ADS_COOLDOWN_MS - (Date.now() - getLastAdTs()); const mins = Math.ceil(rem/60000);
    setMain(`<div class="small">Cooldown active. Try again in ~${mins} minute(s).</div>`); currentView='ad'; return;
  }

  let provider = { ok:false };
  try { provider = await tryLoadAdsterra(ADSTERRA_ZONE_URL, 3500); } catch(e){ provider={ok:false}; }
  if(!provider.ok){
    try { provider = await tryLoadVideoSrc(GOOGLE_FALLBACK_VIDEO, 3000); } catch(e){ provider={ok:false}; }
  }
  if(!provider.ok){
    provider = { ok:true, type:'fallback', node: (function(){ const d=document.createElement('div'); d.innerHTML='<div class="small" style="padding:12px">Ad preview (fallback)</div>'; return d; })() };
  }

  let adId = passedAdId || ('host_ad_'+Math.floor(Math.random()*999999));
  let secs = passedSecs || 40; // default 40s
  let rewardObj = null;

  if(passedReward && passedReward > 0){
    const vipKey = (passedVip||'').toString().toLowerCase();
    const vipBonus = VIP_BONUS[vipKey] || 0;
    rewardObj = { base: Math.max(1, Math.floor(passedReward - vipBonus)), vip_bonus: vipBonus, total: passedReward };
  } else {
    const baseRand = Math.floor(Math.random() * (120 - 60 + 1)) + 60;
    const baseScaled = Math.max(1, Math.floor(baseRand * (secs/30)));
    const vipKey = (profile && profile.vip_level) ? profile.vip_level.toString().toLowerCase() : (passedVip||'').toString().toLowerCase();
    const vipBonus = VIP_BONUS[vipKey] || 0;
    rewardObj = { base: baseScaled, vip_bonus: vipBonus, total: baseScaled + vipBonus };
  }

  addWatched(adId);
  setLastAdTs(Date.now());

  const nodeHtmlId = 'adPlayerNode';
  setMain(`<div class="small">Watching: <strong>${escapeHtml(adId)}</strong> — Reward: <strong>${rewardObj.total} G</strong> <div class="small">(${rewardObj.base} base + ${rewardObj.vip_bonus} VIP)</div></div>
    <div style="margin-top:12px" id="${nodeHtmlId}" class="ad-player"><div class="small">Loading ad…</div></div>
    <div id="adPlayerAdsenseHolder" style="margin-top:12px;text-align:center"></div>
    <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><div class="countdown" id="adCount">${secs}</div></div>
    <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><button id="claimBtn" class="btn" disabled>Claim</button><button id="retBtn" class="btn ghost hidden">Return</button></div>
    <div class="note" id="adNote">Auto-completes after ${secs}s</div>`);

  const container = el(nodeHtmlId);
  if(provider.node){ container.innerHTML=''; container.appendChild(provider.node); if(provider.type==='video'){ try{ provider.node.play().catch(()=>{}); }catch(e){} } }

  try{
    const holder = el('adPlayerAdsenseHolder');
    if(holder){
      holder.innerHTML = `
        <!-- GainGrid_Display_Horizontal (injected) -->
        <ins class="adsbygoogle"
             style="display:inline-block;width:468px;height:60px"
             data-ad-client="ca-pub-2309008538670900"
             data-ad-slot="4194843603"></ins>
      `;
      try{ (adsbygoogle = window.adsbygoogle || []).push({}); }catch(e){ console.warn('adsbygoogle push failed', e); }
      const ampWrap = document.createElement('div');
      ampWrap.style.marginTop = '6px';
      ampWrap.innerHTML = `
        <amp-ad
             layout="fixed"
             width="468"
             height="60"
             type="adsense"
             data-ad-client="ca-pub-2309008538670900"
             data-ad-slot="4194843603">
        </amp-ad>
      `;
      holder.appendChild(ampWrap);
    }
  }catch(e){ console.warn('inject Adsense failed', e); }

  const bannerHolder = document.createElement('div');
  bannerHolder.style.position = 'absolute';
  bannerHolder.style.top = '8px';
  bannerHolder.style.left = '50%';
  bannerHolder.style.transform = 'translateX(-50%)';
  bannerHolder.style.zIndex = '5';
  bannerHolder.id = 'adsterBannerHolder';
  injectAdsterraIntoElement(bannerHolder);
  if(container && container.parentElement) container.parentElement.appendChild(bannerHolder);

  const countEl = el('adCount'), claimBtn = el('claimBtn'), retBtn = el('retBtn'), adNote = el('adNote');
  let remaining = secs;
  if(countEl) countEl.textContent = remaining;
  const tick = setInterval(()=>{
    remaining--;
    if(countEl) countEl.textContent = remaining;
    if(remaining <= 0){
      clearInterval(tick);
      if(claimBtn) claimBtn.disabled = false;
      adNote.textContent = 'Ad finished. Sending result...';
      const payload = {
        ad_id: adId,
        reward: rewardObj.total,
        base: rewardObj.base,
        vip_bonus: rewardObj.vip_bonus,
        vip_level: vipFrom(qpCombined) || passedVip || null,
        user_id: (profile && profile.user_id) || null,
        status: 'completed'
      };
      postParent({ type:'ad_complete', payload });
      postParent({ type:'task_complete', payload });
      if(retBtn){ retBtn.classList.remove('hidden'); retBtn.textContent = (detectSource(qpCombined) === 'ui' ? 'Return to Game' : 'Close'); }
      setTimeout(()=>{ postParent({ type:'close_hosted', reason:'ad_done', payload }); try{ if(window.close) window.close(); }catch(e){} }, 900);
    }
  }, 1000);

  claimBtn && claimBtn.addEventListener('click', ()=>{
    if(claimBtn.disabled) return;
    const payload = {
      ad_id: adId,
      reward: rewardObj.total,
      base: rewardObj.base,
      vip_bonus: rewardObj.vip_bonus,
      vip_level: vipFrom(qpCombined) || passedVip || null,
      user_id: (profile && profile.user_id) || null,
      status: 'completed'
    };
    postParent({ type:'ad_complete', payload });
    if(retBtn){ retBtn.classList.remove('hidden'); retBtn.textContent = (detectSource(qpCombined) === 'ui' ? 'Return to Game' : 'Close'); }
  });

  retBtn && retBtn.addEventListener('click', ()=> {
    postParent({ type:'close_hosted', reason:'user_return' });
    try{ if(window.close) window.close(); }catch(e){}
  });
}

/* ===== Adsterra injection helpers (kept) ===== */
function injectAdsterraInto(idOrElem){
  let holder = null;
  if(typeof idOrElem === 'string') holder = document.getElementById(idOrElem);
  else holder = idOrElem;
  if(!holder) return;
  holder.innerHTML = '';
  const wrap = document.createElement('div');
  wrap.style.width = '468px';
  wrap.style.maxWidth = '100%';
  wrap.style.height = '60px';
  wrap.style.margin = '0 auto';
  wrap.style.overflow = 'hidden';
  const s1 = document.createElement('script');
  s1.type = 'text/javascript';
  s1.text = "atOptions = { 'key' : '" + ADSTER_SCRIPT_KEY + "', 'format' : 'iframe', 'height' : 60, 'width' : 468, 'params' : {} };";
  wrap.appendChild(s1);
  const s2 = document.createElement('script');
  s2.type = 'text/javascript';
  s2.src = ADSTER_SCRIPT_SRC;
  wrap.appendChild(s2);
  holder.appendChild(wrap);
}
function injectAdsterraIntoElement(elem){
  try{
    const s1 = document.createElement('script');
    s1.type = 'text/javascript';
    s1.text = "atOptions = { 'key' : '" + ADSTER_SCRIPT_KEY + "', 'format' : 'iframe', 'height' : 60, 'width' : 468, 'params' : {} };";
    elem.appendChild(s1);
    const s2 = document.createElement('script');
    s2.type = 'text/javascript';
    s2.src = ADSTER_SCRIPT_SRC;
    elem.appendChild(s2);
  }catch(e){ console.warn('injectAdsterraIntoElement failed', e); }
}

/* ===== routing & message handling (kept names) ===== */
function detectSource(qp){ qp = qp || combinedQP(); if(qp._source === 'ui') return 'ui'; if(qp.start) return 'deeplink'; if(qp.ad_id || qp.task_id){ if(qp.user_id || qp.vip || qp.vip_level) return 'ui'; return 'deeplink'; } return 'ui'; }
function decodeStart(raw){
  if(!raw) return null;
  try{
    const norm = raw.replace(/-/g,'+').replace(/_/g,'/');
    const json = atob(norm); return JSON.parse(json);
  }catch(e){
    try{ return JSON.parse(decodeURIComponent(raw)); }catch(e){ return null; }
  }
}

/* parent message handler: receive profile, open commands, parent-provided tasks, or forwarded verifications */
window.addEventListener('message', function(ev){
  try{
    const d = ev.data || {};
    if(!d || typeof d !== 'object') return;

    // update debug badge when messages arrive
    try{ if(window.__hostedDebug) window.__hostedDebug(d.type || 'msg'); }catch(e){}

    if(d.type === 'profile_response' && d.payload){ profile = d.payload; setVIPLabel(); }

    // Accept authoritative tasks array from parent (legacy compatibility)
    if(d.type === 'start_payload' && d.payload){
      const p = d.payload;
      if(Array.isArray(p.tasks) && p.tasks.length){
        const mapped = p.tasks.map(t => ({
          id: t.id || t.task_id || ('task_' + Math.random().toString(36).slice(2,8)),
          title: t.title || t.name || ('Task ' + (t.id||'')),
          secs: t.secs || t.duration || 30,
          reward: t.reward || t.base || 0,
          url: t.url || t.link || '',
          tag: t.tag || t.type || ''
        }));
        PARENT_TASKS = mapped;
        renderTasksFromParent(PARENT_TASKS);
        return;
      }

      if(p && (p.ad_id || p.task_id || p.id)){
        const incoming = Object.assign({}, p, { from: 'ui' });
        if(p.ad_id || p.type === 'ad' || p.isAd){
          renderAdFlow({ ad_id: p.ad_id || p.id, secs: p.secs, reward: p.reward, vip: p.vip, vip_level: p.vip_level });
          return;
        }
        if(p.task_id || p.type === 'task' || p.isTask){
          if(PARENT_TASKS && PARENT_TASKS.length){
            renderTasksFromParent(PARENT_TASKS);
            return;
          } else {
            awaitRunTaskFlowFromPayload(p);
            return;
          }
        }
      }
    }

    if(d.type === 'open_ad' && d.payload && d.payload.ad_id){
      location.hash = '#/ad?id=' + encodeURIComponent(d.payload.ad_id) + '&secs=' + encodeURIComponent(d.payload.secs||'') + '&reward=' + encodeURIComponent(d.payload.reward||'') + '&vip=' + encodeURIComponent(d.payload.vip||'');
      router();
    }
    if(d.type === 'open_task' && d.payload && d.payload.task_id){
      location.hash = '#/task?id=' + encodeURIComponent(d.payload.task_id) + '&secs=' + encodeURIComponent(d.payload.secs||'') + '&reward=' + encodeURIComponent(d.payload.reward||'');
      router();
    }
    if(d.type === 'request_close_from_parent' || d.type === 'request_close'){
      try{ if(window.close) window.close(); }catch(e){} // try to self-close
    }
  }catch(e){}
});

/* helper: run runTaskFlow with payload values (ADDED) */
function awaitRunTaskFlowFromPayload(p){
  try{
    const id = p.task_id || p.id || ('task_' + Math.random().toString(36).slice(2,8));
    const secs = Number(p.secs || p.duration || 30);
    const reward = Number(p.reward || p.base || 0);
    const url = p.url || p.link || '';
    setTimeout(()=> { try{ runTaskFlow({ task_id: id, url, secs, rewardBase: reward, reward: reward, _source:'ui' }); }catch(e){ console.warn('awaitRunTaskFlowFromPayload err', e); } }, 10);
  }catch(e){ console.warn('awaitRunTaskFlowFromPayload', e); }
}

/* router */
async function router(){
  profile = profile || readLocalProfile() || null;
  setVIPLabel();
  const qp = combinedQP();

  if(qp.start){
    const decoded = decodeStart(qp.start);
    if(decoded){
      const action = (decoded.action || decoded.cmd || decoded.type || '').toString().toLowerCase();
      const payload = decoded.payload || decoded.data || decoded;
      if(action.includes('ad') || action.includes('watch')){
        if(payload && (payload.ad_id || payload.id)) qp.ad_id = payload.ad_id || payload.id;
        qp.vip = qp.vip || payload.vip || payload.vip_level;
        await renderAdFlow(qp);
        return;
      } else if(action.includes('task')){
        if(payload && (payload.task_id || payload.id)) qp.task_id = payload.task_id || payload.id;
        qp.vip = qp.vip || payload.vip || payload.vip_level;
        await renderTaskBoard(qp);
        return;
      }
    }
  }

  if(qp.ad_id || qp.id || (location.hash && location.hash.toLowerCase().includes('/ad'))){
    await renderAdFlow(qp);
    return;
  }
  if(qp.task_id || qp.id || (location.hash && location.hash.toLowerCase().includes('/task'))){
    await renderTaskBoard(qp);
    return;
  }

  setMain(`<div class="small">Hosted — waiting for instruction. If parent opened an ad/task it will appear automatically.</div>`);
}

/* ===== startup: run after DOM ready (FIX: avoid race on immediate execution) ===== */
// FIX: ensure we initialize only after DOM is ready (prevents timers firing before parent handshake)
function startHostedBoot(){
  try{
    generateDailyAds();
    router();
    // wire back button to notify parent (FIX: added Close/Back behavior)
    try{
      const back = el('backBtn');
      if(back){
        back.addEventListener('click', ()=> {
          postParent({ type:'close_hosted', reason:'user_back' });
          try{ if(window.close) window.close(); }catch(e){}
        });
      }
    }catch(e){ console.warn('backBtn wire err', e); }
  }catch(e){ console.warn('hosted boot err', e); }
}
if(document.readyState === 'loading'){
  document.addEventListener('DOMContentLoaded', startHostedBoot);
} else {
  startHostedBoot();
}

/* debug toggle */
try{ const q = combinedQP(); if(q.dbg === '1'){ el('dbg').classList.add('dbg-visible'); el('dbg').textContent = 'dbg on'; } }catch(e){}
</script>
</body>
</html>