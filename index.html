<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>GainGrid Hosted — Ads Player</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

<!-- Google AdSense core script (kept) -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2309008538670900"
     crossorigin="anonymous"></script>

<style>
  :root{
    --accent1:#ff6b9d; --accent2:#c471ed;
    --bg:linear-gradient(135deg,#0f1419 0,#1a2332 50%,#0d1117 100%);
  }
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;color:#fff;background:var(--bg)}
  .viewport-wrap{width:100%;height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
  .card{width:var(--card-width,420px);height:var(--card-height,520px);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(0,0,0,0.5);display:flex;flex-direction:column;overflow:hidden}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex:0 0 auto}
  .back-btn{background:transparent;border:0;color:rgba(255,255,255,0.9);cursor:pointer;font-weight:700}
  h2{margin:0;font-size:16px}
  .small{font-size:12px;color:rgba(255,255,255,0.78)}
  .btn{padding:8px 10px;border-radius:8px;background:linear-gradient(45deg,var(--accent1),var(--accent2));border:none;color:#fff;cursor:pointer;font-weight:700}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .content{flex:1 1 auto;overflow:hidden;display:flex;flex-direction:column}
  .ad-player{width:100%;height:var(--ad-height,320px);border-radius:8px;overflow:hidden;background:#000;display:flex;align-items:center;justify-content:center;position:relative;margin-top:12px}
  .ad-player iframe,.ad-player video{width:100%;height:100%;border:0;object-fit:cover}
  .note{margin-top:8px;color:rgba(255,255,255,0.6);font-size:12px}
  .countdown{font-weight:700;font-size:18px;color:#fff}
  .hidden{display:none}
  #adPlayerAdsenseHolder, #adsterBannerHolder{display:flex;justify-content:center;align-items:center}
  .dbg{position:absolute;left:8px;bottom:8px;padding:6px 8px;background:rgba(0,0,0,0.6);border-radius:6px;font-size:11px;color:#fff;z-index:50;display:none}
  .dbg.dbg-visible{display:block}
  .controls{display:flex;gap:8px;margin-top:10px;justify-content:center;align-items:center}
  .muted-note{font-size:11px;color:rgba(255,255,255,0.5);text-align:center;margin-top:6px}
  .disabled{opacity:0.45;pointer-events:none}
</style>
</head>
<body>
  <div class="viewport-wrap">
    <div class="card" id="root">
      <div class="topbar">
        <button id="backBtn" class="back-btn">← Close</button>
        <div style="text-align:right">
          <div class="small" id="vipInfo">VIP: —</div>
        </div>
      </div>

      <div class="content">
        <div id="main" class="small">Initializing…</div>

        <!-- ad player container -->
        <div class="ad-player" id="adPlayer">
          <!-- video or ad iframe will be injected here -->
          <div id="adPlaceholder" class="small" style="color:#999;">Ad player area</div>
        </div>

        <div class="controls" id="controls" aria-hidden="true" style="margin-top:12px">
          <div id="countWrap" style="display:flex;align-items:center;gap:10px">
            <div class="small">Time left:</div>
            <div class="countdown" id="adCount">--</div>
          </div>

          <button id="claimBtn" class="btn" disabled>Claim</button>
          <button id="skipBtn" class="btn ghost hidden">Skip</button>
          <button id="backToBtn" class="btn ghost hidden">Back</button>
        </div>

        <div id="adsterBannerHolder" style="margin-top:12px"></div>
        <div id="adPlayerAdsenseHolder" style="margin-top:8px"></div>

        <div class="note" id="noteArea" style="margin-top:8px"></div>
        <div class="muted-note" id="mutedNote">Autoplay may be blocked by browser; allow autoplay in iframe or browser settings.</div>
      </div>

      <div class="dbg" id="dbg">dbg</div>
    </div>
  </div>

<script>
/* ========================
   GainGrid Hosted — simplified ad-only hosted
   Supports:
     - parent iframe (gain.web) via postMessage (mode: iframe)
     - deeplink start payload (?start=<base64>) (mode: deeplink)
     - standalone (mode: standalone) — inert UI
   Behavior:
     - ad flow only (no task board, no public UI)
     - handshake with parent: hosted_ready, hosted_opened, ad_complete
     - deeplink: reads start payload (game_name, webhook, user) and returns validation after ad
     - auto-clean stored payload on new payload
   ======================== */

(function(){
  'use strict';

  /* ---------- CONFIG ---------- */
  // Allowed hosted origin (for parent checks) — change to your domain (no trailing slash)
  const HOSTED_ORIGIN = (location.origin || (new URL(location.href)).origin); // canonical origin for self
  const KEY_AUTH = 'gg_hosted_authoritative_payload_v2';
  const KEY_PROFILE = 'gg_hosted_profile_v2';
  const AD_DURATIONS = [30,40,50,60];

  /* ---------- DOM ---------- */
  const d = id => document.getElementById(id);
  const main = d('main');
  const adPlayer = d('adPlayer');
  const adPlaceholder = d('adPlaceholder');
  const controls = d('controls');
  const adCountEl = d('adCount');
  const claimBtn = d('claimBtn');
  const skipBtn = d('skipBtn');
  const backToBtn = d('backToBtn');
  const backBtn = d('backBtn');
  const noteArea = d('noteArea');
  const vipInfo = d('vipInfo');
  const dbg = d('dbg');

  /* ---------- STATE ---------- */
  let MODE = 'standalone'; // 'iframe' | 'deeplink' | 'standalone'
  let authoritativePayload = null; // stored payload
  let startPayload = null; // decoded deeplink or parent payload
  let adTimer = null;
  let remaining = 0;
  let currentAd = null; // { ad_id, secs, reward, user, vip_level, meta }
  let isFinished = false;

  /* ---------- utilities ---------- */
  function log(...args){ try{ console.log('[hosted]', ...args); }catch(e){} }
  function setDbg(txt){ if(dbg){ dbg.textContent = txt; dbg.classList.add('dbg-visible'); setTimeout(()=> dbg.classList.remove('dbg-visible'), 2200); } }
  function now(){ return Date.now(); }
  function randFrom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  /* ---------- storage helpers (auto-clean on new payload) ---------- */
  function saveAuth(p){
    try{ sessionStorage.setItem(KEY_AUTH, JSON.stringify(p)); authoritativePayload = p; }catch(e){}
  }
  function clearAuth(){ try{ sessionStorage.removeItem(KEY_AUTH); authoritativePayload = null; }catch(e){} }
  function readAuth(){ try{ return JSON.parse(sessionStorage.getItem(KEY_AUTH)||'null'); }catch(e){ return null; } }

  function applyVip(u){
    try{ if(!u) return; const vip = (u.vip_level||u.vip) ? (u.vip_level||u.vip) : '—'; if(vipInfo) vipInfo.textContent = 'VIP: ' + vip; }catch(e){}
  }

  /* ---------- decode helpers ---------- */
  function tryDecodeBase64Safe(raw){
    if(!raw) return null;
    try{
      // URL-safe -> normal
      const norm = raw.replace(/-/g,'+').replace(/_/g,'/');
      const pad = norm.length % 4;
      let padded = norm;
      if(pad === 2) padded += '==';
      else if(pad === 3) padded += '=';
      const json = atob(padded);
      return JSON.parse(json);
    }catch(e){
      try{ return JSON.parse(decodeURIComponent(raw)); }catch(e){ return null; }
    }
  }

  /* ---------- mode detection: querystring parsing ---------- */
  function qsParse(){ const s = location.search.replace(/^\?/,''); if(!s) return {}; return s.split('&').filter(Boolean).map(p=>{ const idx=p.indexOf('='); if(idx<0) return [decodeURIComponent(p),'']; const k=decodeURIComponent(p.slice(0,idx)); const v=decodeURIComponent(p.slice(idx+1)); return [k,v]; }).reduce((acc,[k,v])=>{ if(acc[k]===undefined) acc[k]=v; else if(Array.isArray(acc[k])) acc[k].push(v); else acc[k]=[acc[k],v]; return acc; }, {}); }
  const QS = qsParse();

  // decode Telegram start payload if present
  let deeplinkStartPayload = null;
  if(QS.start){
    deeplinkStartPayload = tryDecodeBase64Safe(QS.start);
    if(deeplinkStartPayload) {
      MODE = 'deeplink';
      startPayload = deeplinkStartPayload;
      saveAuth(startPayload);
      applyVip(startPayload.payload || startPayload.user || startPayload);
      setDbg('deeplink start');
    }
  }

  // if inside an iframe (parent different), tentatively set iframe mode (gain.web)
  if(window.parent && window.parent !== window){
    // wait for parent handshake message to confirm, but allow iframe flows
    MODE = MODE === 'deeplink' ? MODE : 'iframe';
    setDbg('iframe detected');
  }

  /* ---------- handshake & message handling ---------- */
  // Accept messages from parent (gain.web). Use permissive origin by default but you may harden it.
  function isAllowedOrigin(origin){
    if(!origin) return true; // allow empty for local/dev
    try{ const u = new URL(location.href); return origin === u.origin || origin === (new URL(u.origin)).origin; }catch(e){ return true; }
  }

  // Post to parent & opener (safe)
  function postToParent(msg){
    try{ if(window.parent && window.parent !== window) window.parent.postMessage(msg, '*'); }catch(e){}
    try{ if(window.opener && !window.opener.closed) window.opener.postMessage(msg, '*'); }catch(e){}
  }

  // announce ready (handshake)
  function announceReady(){ postToParent({ type:'hosted_ready', payload:{ ts: now(), href: location.href, mode: MODE, ad_id: (authoritativePayload && (authoritativePayload.ad_id || authoritativePayload.id)) || null } }); setDbg('ready'); }

  // queue early messages until ready
  window.__HOSTED_INCOMING_QUEUE = window.__HOSTED_INCOMING_QUEUE || [];
  window.__HOSTED_IS_READY = false;
  function consumeQueue(){
    window.__HOSTED_IS_READY = true;
    while(window.__HOSTED_INCOMING_QUEUE.length){
      const msg = window.__HOSTED_INCOMING_QUEUE.shift();
      if(msg && msg.type) handleParentMessage({ data: msg });
    }
  }

  // handle incoming messages from parent
  function handleParentMessage(ev){
    try{
      const origin = ev.origin || (ev.data && ev.data._origin) || '';
      if(!isAllowedOrigin(origin)) return;
      const data = ev.data || {};
      if(!data || typeof data !== 'object') return;

      // ping / keepalive
      if(data.type === 'ping_hosted'){ postToParent({ type:'hosted_pong', payload:{ ts: now() } }); return; }

      // authoritative start payload (parent tells hosted to run ad)
      if((data.type === 'start_payload' || data.type === 'open_ad' || data.type === 'open_task') && data.payload){
        clearAuth();
        saveAuth(data.payload);
        startPayload = data.payload;
        MODE = 'iframe';
        applyVip(startPayload.user || startPayload.payload || startPayload);
        setDbg('start_payload received');
        // if payload requests immediate ad open, start it
        if(data.type === 'open_ad' || (startPayload && (startPayload.ad_id || startPayload.id || startPayload.type === 'ad'))){
          const p = startPayload;
          const adObj = {
            ad_id: p.ad_id || p.id || ('host_ad_' + Date.now()),
            secs: Number(p.secs || p.duration || p.s || p.timeout) || null,
            reward: Number(p.reward || p.r || p.base) || 0,
            user: p.user || (p.profile || null),
            vip_level: p.vip_level || p.vip || null,
            meta: p.meta || null
          };
          startAdFlow(adObj, { invokedBy: 'parent' });
        }
        return;
      }

      // parent requested close
      if(data.type === 'request_close' || data.type === 'close_hosted'){
        tryClose();
        return;
      }

      // profile response — update VIP UI
      if(data.type === 'profile_response' && data.payload){
        applyVip(data.payload || data.payload.user);
        return;
      }

    }catch(e){ console.warn('handleParentMessage err', e); }
  }

  window.addEventListener('message', function(ev){
    // If not ready yet, queue messages to avoid race
    if(!window.__HOSTED_IS_READY){
      window.__HOSTED_INCOMING_QUEUE.push(ev.data || ev);
      return;
    }
    handleParentMessage(ev);
  }, false);

  /* ---------- UI helpers ---------- */
  function resetUI(){
    isFinished = false;
    clearInterval(adTimer);
    adTimer = null;
    remaining = 0;
    adCountEl.textContent = '--';
    claimBtn.disabled = true;
    claimBtn.classList.add('disabled');
    claimBtn.classList.remove('hidden');
    skipBtn.classList.add('hidden');
    backToBtn.classList.add('hidden');
    noteArea.textContent = '';
  }

  function enableControlsForMode(mode){
    controls.setAttribute('aria-hidden','false');
    if(mode === 'iframe'){
      // parent: show claim button disabled until finished, show countdown
      claimBtn.disabled = true; claimBtn.classList.add('disabled');
      skipBtn.classList.add('hidden');
      backToBtn.classList.add('hidden');
    } else if(mode === 'deeplink'){
      // deeplink: show Skip button active (user may skip). Claim not used.
      claimBtn.classList.add('hidden');
      skipBtn.classList.remove('hidden'); skipBtn.disabled = false; skipBtn.classList.remove('disabled');
      backToBtn.classList.add('hidden');
    } else { // standalone
      claimBtn.disabled = true; claimBtn.classList.add('disabled');
      skipBtn.classList.add('hidden');
      backToBtn.classList.add('hidden');
      controls.classList.add('disabled');
    }
  }

  /* ---------- Adsterra & AdSense injection (kept minimal) ---------- */
  function injectAdsterra(holderId){
    try{
      const holder = d(holderId);
      if(!holder) return;
      holder.innerHTML = '';
      const wrap = document.createElement('div'); wrap.style.width='468px'; wrap.style.maxWidth='100%'; wrap.style.height='60px'; wrap.style.margin='0 auto';
      const s1 = document.createElement('script'); s1.type='text/javascript';
      s1.text = "atOptions = { 'key' : 'a8702b8b4c48420a3815542007f1c0df', 'format' : 'iframe', 'height' : 60, 'width' : 468, 'params' : {} };";
      wrap.appendChild(s1);
      const s2 = document.createElement('script'); s2.type='text/javascript'; s2.src = "//www.highperformanceformat.com/a8702b8b4c48420a3815542007f1c0df/invoke.js";
      wrap.appendChild(s2);
      holder.appendChild(wrap);
    }catch(e){ console.warn('injectAdsterra err', e); }
  }

  function injectAdsense(holderId){
    try{
      const holder = d(holderId);
      if(!holder) return;
      holder.innerHTML = `<ins class="adsbygoogle" style="display:inline-block;width:320px;height:50px" data-ad-client="ca-pub-2309008538670900" data-ad-slot="4194843603"></ins>`;
      try{ (window.adsbygoogle = window.adsbygoogle || []).push({}); }catch(e){}
    }catch(e){ console.warn('injectAdsense err', e); }
  }

  /* ---------- ad rendering ---------- */
  function renderAdPlayerUsingVideo(src){
    // use a muted autoplaying video as fallback for testing
    adPlayer.innerHTML = '';
    const video = document.createElement('video');
    video.src = src || 'https://storage.googleapis.com/interactive-media-ads/media/big_buck_bunny_trailer.mp4';
    video.autoplay = true; video.muted = true; video.playsInline = true; video.controls = false;
    video.style.width = '100%'; video.style.height = '100%'; video.style.objectFit = 'cover';
    adPlayer.appendChild(video);
    return video;
  }

  /* ---------- main ad flow (shared) ---------- */
  function startAdFlow(adObj, opts = {}){
    // opts.invokedBy: 'parent' | 'deeplink' | 'manual'
    try{
      resetUI();
      currentAd = adObj || { ad_id: 'host_ad_' + Date.now(), secs: null, reward: 0 };
      isFinished = false;

      // cleanup any previous stored auth and save new authoritative payload
      clearAuth();
      saveAuth(adObj);

      // ensure secs: if not provided, choose random from AD_DURATIONS (used for deeplink + fallback)
      if(!currentAd.secs || Number.isNaN(Number(currentAd.secs))){
        currentAd.secs = Number(randFrom(AD_DURATIONS));
      } else {
        currentAd.secs = Number(currentAd.secs);
      }

      // show ad player (video) — always present
      const video = renderAdPlayerUsingVideo(currentAd.video || currentAd.src || null);

      // show Adsterra / AdSense
      injectAdsterra('adsterBannerHolder');
      injectAdsense('adPlayerAdsenseHolder');

      // set mode-specific controls
      enableControlsForMode(MODE);

      // announce opened to parent for handshake
      postToParent({ type:'hosted_opened', payload: { ad_id: currentAd.ad_id, secs: currentAd.secs, reward: currentAd.reward || 0 } });

      // start countdown only for iframe and deeplink modes
      if(MODE === 'iframe' || MODE === 'deeplink'){
        remaining = Number(currentAd.secs || 30);
        adCountEl.textContent = remaining;
        adTimer = setInterval(()=>{
          remaining--;
          adCountEl.textContent = remaining;
          if(remaining <= 0){
            clearInterval(adTimer);
            onAdFinished();
          }
        }, 1000);
      } else {
        // standalone: show inert placeholder but do not start countdown
        adCountEl.textContent = '--';
        noteArea.textContent = 'Standalone demo: countdown disabled. Opened directly in browser.';
      }

      // wire claim / skip / back buttons
      // Claim -> used in iframe (parent) flows
      claimBtn.onclick = function(){
        if(claimBtn.disabled) return;
        finalizeForParent({ reason: 'claimed_by_user' });
      };

      // Skip -> used for deeplink to allow early skip
      skipBtn.onclick = function(){
        if(MODE !== 'deeplink') return;
        // mark finished and send "skipped" result
        isFinished = true;
        finalizeForDeeplink({ skipped: true });
      };

      // Back button -> visible after finish
      backToBtn.onclick = function(){
        // behavior depends on mode
        if(MODE === 'iframe'){
          postToParent({ type:'close_hosted', payload: { reason:'user_return', ad_id: currentAd.ad_id } });
          tryClose();
        } else if(MODE === 'deeplink'){
          // for deeplink, send a message back to opener if exists
          finalizeForDeeplink({ navigate_back: true });
        } else {
          tryClose();
        }
      };

      // make sure backBtn top-left closes (works across hosts)
      backBtn.onclick = tryClose;

      setDbg('ad started ' + currentAd.ad_id);

    }catch(e){ console.warn('startAdFlow err', e); }
  }

  /* ---------- finish handlers ---------- */
  function onAdFinished(){
    if(isFinished) return;
    isFinished = true;
    setDbg('ad finished');
    adCountEl.textContent = 0;
    noteArea.textContent = 'Ad finished. Validating...';

    if(MODE === 'iframe'){
      // enable Claim button for parent flow
      claimBtn.disabled = false; claimBtn.classList.remove('disabled');
      // auto-send ad_complete if you want immediate auto-complete (we keep manual claim by default)
      // Here we auto-notify parent, but keep claim flow to let them decide awarding:
      postToParent({ type:'ad_complete', payload: { ad_id: currentAd.ad_id, reward: currentAd.reward || 0, base: currentAd.base || 0, vip_bonus: currentAd.vip_bonus || 0, vip_level: currentAd.vip_level || null, meta: { ts: now() } } });
      // show back button to allow parent to return user
      backToBtn.textContent = 'Back to dash';
      backToBtn.classList.remove('hidden');
    } else if(MODE === 'deeplink'){
      // show Back to Game button (replace skip)
      skipBtn.classList.add('hidden');
      backToBtn.textContent = 'Back to game';
      backToBtn.classList.remove('hidden');
      // send validation back to bot (via webhook in startPayload or via deep-link)
      finalizeForDeeplink({ skipped: false });
    } else {
      // standalone: inert — do not send anything
      noteArea.textContent = 'Ad finished (standalone demo). No validation in demo mode.';
    }
  }

  /* finalize for parent (iframe) — called when claim pressed or auto-complete desired */
  function finalizeForParent(opts = {}){
    try{
      const payload = {
        ad_id: currentAd.ad_id,
        reward: currentAd.reward || 0,
        base: currentAd.base || 0,
        vip_bonus: currentAd.vip_bonus || 0,
        vip_level: currentAd.vip_level || null,
        user_id: (currentAd.user && currentAd.user.user_id) || null,
        status: (opts.skipped ? 'skipped' : 'completed'),
        meta: { ts: now(), source: 'hosted_iframe' }
      };
      // send ad_complete and task_complete compatibility
      postToParent({ type:'ad_complete', payload });
      postToParent({ type:'task_complete', payload });
      // attempt webhook if provided in auth
      try{
        const auth = readAuth();
        const wh = auth && (auth.webhook || auth.callback || auth.hook || auth.url);
        if(wh){
          fetch(wh, { method: 'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ action:'ads_validate', payload }), keepalive: true }).catch(()=>{});
        }
      }catch(e){}
      noteArea.textContent = 'Sent validation to parent.';
      // show back
      backToBtn.textContent = 'Back to dash';
      backToBtn.classList.remove('hidden');
    }catch(e){ console.warn('finalizeForParent err', e); }
  }

  /* finalize for deeplink — send back to webhook or deep-link to bot with payload */
  async function finalizeForDeeplink(opts = {}){
    try{
      const sp = startPayload || readAuth();
      const gameName = (sp && sp.payload && sp.payload.game_name) || (sp && sp.game_name) || null;
      const user = (sp && sp.payload && sp.payload.user) || (sp && sp.user) || null;
      const webhook = (sp && sp.payload && sp.payload.callback_url) || (sp && sp.webhook) || (sp && sp.payload && sp.payload.webhook) || null;
      const botDeep = (sp && sp.payload && sp.payload.bot_deeplink) || (sp && sp.bot_deeplink) || null;

      const result = {
        ad_id: currentAd.ad_id,
        reward: currentAd.reward || 0,
        base: currentAd.base || 0,
        vip_bonus: currentAd.vip_bonus || 0,
        vip_level: currentAd.vip_level || null,
        user_id: (user && (user.user_id||user.id)) || (sp && sp.user_id) || null,
        game_name: gameName || null,
        status: (opts.skipped ? 'skipped' : 'completed'),
        meta: { ts: now(), source: 'hosted_deeplink' }
      };

      // prefer webhook if provided
      if(webhook){
        try{
          await fetch(webhook, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ action: 'ads_validate', payload: result }), keepalive: true });
          noteArea.textContent = 'Validation sent to webhook.';
        }catch(e){
          console.warn('webhook POST failed', e);
          noteArea.textContent = 'Validation webhook failed.';
        }
      } else if(botDeep){
        // open bot deeplink with payload (base64) — this will open the bot and pass result
        try{
          const b = btoa(JSON.stringify({ action:'ads_validate', payload: result })).replace(/=+$/,'');
          const url = botDeep.includes('t.me') ? botDeep + '?start=' + encodeURIComponent(b) : ('https://t.me/' + botDeep + '?start=' + encodeURIComponent(b));
          window.open(url, '_blank');
          noteArea.textContent = 'Sent validation via bot deeplink.';
        }catch(e){
          console.warn('bot deeplink failed', e);
        }
      } else {
        // as final fallback, postMessage to opener (if exists)
        try{ if(window.opener && !window.opener.closed) window.opener.postMessage({ type:'ads_validate', payload: result }, '*'); }catch(e){}
        noteArea.textContent = 'Validation posted to opener (fallback).';
      }

      // if in Telegram WebApp try to close
      try{
        if(window.Telegram && Telegram.WebApp && typeof Telegram.WebApp.close === 'function'){
          setTimeout(()=>{ try{ Telegram.WebApp.close(); }catch(e){} }, 900);
        } else {
          // otherwise we can close the window (may be blocked in some browsers)
          setTimeout(()=>{ try{ window.close(); }catch(e){} }, 900);
        }
      }catch(e){ /* ignore */ }

    }catch(e){ console.warn('finalizeForDeeplink err', e); }
  }

  /* ---------- utility: tryClose ---------- */
  function tryClose(){
    try{
      // try Telegram.WebApp.close first
      if(window.Telegram && Telegram.WebApp && typeof Telegram.WebApp.close === 'function'){
        try{ Telegram.WebApp.close(); return; }catch(e){}
      }
      // try window.close
      try{ window.close(); }catch(e){ /*ignore*/ }
    }catch(e){}
  }

  /* ---------- page startup ---------- */

  // announce ready shortly after DOM ready
  if(document.readyState === 'complete' || document.readyState === 'interactive'){
    setTimeout(()=>{ announceReady(); consumeQueue(); window.__HOSTED_IS_READY = true; }, 60);
  } else {
    document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(()=>{ announceReady(); consumeQueue(); window.__HOSTED_IS_READY = true; }, 60); });
  }

  // render minimal inert UI for standalone (if still in standalone)
  function renderInitial(){
    resetUI();
    main.textContent = 'Hosted ad player ready.';
    injectAdsterra('adsterBannerHolder');
    injectAdsense('adPlayerAdsenseHolder');
    setDbg('initial render');
  }
  renderInitial();

  /* ---------- quick auto-open behavior:
       - if we have an authoritative payload in sessionStorage (e.g. parent pre-wrote it via hash),
         then start ad automatically (useful for #/ad?payload style).
  */
  (function autoStartFromHashOrStored(){
    try{
      // 1) if location.hash contains base64 payload param `p` or direct /ad path, decode it
      const h = (location.hash||'').replace(/^#/,'');
      if(h){
        // support #/ad?p=<b64> and #/ad?ad_id=...
        if(h.startsWith('/ad') || h.startsWith('ad')){
          const parts = h.split('?');
          const path = parts[0].replace(/^\//,'').toLowerCase();
          const qp = {};
          if(parts[1]) parts[1].split('&').forEach(p=>{ const i=p.indexOf('='); if(i>=0) qp[decodeURIComponent(p.slice(0,i))]=decodeURIComponent(p.slice(i+1)); else qp[decodeURIComponent(p)]=''; });
          if(qp.p){
            const decoded = tryDecodeBase64Safe(decodeURIComponent(qp.p));
            if(decoded){
              MODE = 'standalone'; // hash-opened publicly but contains payload — treat as direct deeplink-like but no opener
              startPayload = decoded;
              saveAuth(decoded);
              applyVip(decoded.payload||decoded.user||decoded);
              // start ad after slight delay
              setTimeout(()=> startAdFlow({
                ad_id: decoded.payload && (decoded.payload.ad_id || decoded.payload.id) || decoded.ad_id || ('host_ad_' + Date.now()),
                secs: Number(decoded.payload && decoded.payload.secs) || Number(decoded.secs) || null,
                reward: Number(decoded.payload && decoded.payload.reward) || Number(decoded.reward) || 0,
                user: decoded.payload && decoded.payload.user || null
              }, { invokedBy: 'hash' }), 220);
              return;
            }
          } else if(qp.ad_id || qp.id){
            MODE = 'standalone';
            startAdFlow({ ad_id: qp.ad_id||qp.id, secs: qp.secs||qp.duration||null }, { invokedBy: 'hash' });
            return;
          }
        }
      }

      // 2) if session storage has KEY_AUTH, start ad automatically (parent may have pre-seeded)
      const stored = (function(){ try{ return JSON.parse(sessionStorage.getItem(KEY_AUTH)||'null'); }catch(e){ return null; } })();
      if(stored && stored.ad_id){
        // treat as iframe mode if parent present, otherwise standalone
        if(window.parent && window.parent !== window) MODE = 'iframe';
        startPayload = stored;
        setTimeout(()=> startAdFlow({
          ad_id: stored.ad_id || stored.id,
          secs: stored.secs || stored.duration || stored.s,
          reward: stored.reward || stored.r || stored.base || 0,
          user: stored.user || stored.profile || null
        }, { invokedBy: 'stored' }), 120);
      }
    }catch(e){ console.warn('autoStartFromHashOrStored err', e); }
  })();

  /* ---------- clean up stored properties automatically when a new payload arrives ----------
     Note: saveAuth() already overwrites; but to ensure old ones don't linger across sessions,
     we clear older keys on new start.
  */
  (function autoCleanupOldKeys(){
    try{
      const keysToClear = ['gg_hosted_tasks_done','gg_hosted_last_ad_payload'];
      keysToClear.forEach(k=> localStorage.removeItem(k));
    }catch(e){}
  })();

  /* ---------- expose some debug helpers to console ---------- */
  window.__hosted_startAd = (ad)=> startAdFlow(ad||{ ad_id:'dbg_'+Date.now(), secs:30, reward:1 }, { invokedBy:'manual' });
  window.__hosted_clear = ()=> { clearAuth(); resetUI(); setDbg('cleared'); };

})();
</script>
</body>
</html>