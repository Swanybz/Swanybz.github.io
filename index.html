<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>GainGrid Hosted — Ads (iframe-ready)</title>

<!-- AdSense core (kept) -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2309008538670900"
     crossorigin="anonymous"></script>

<style>
  :root{
    --accent1:#ff6b9d; --accent2:#c471ed;
    --bg:linear-gradient(135deg,#0f1419 0,#1a2332 50%,#0d1117 100%);
  }
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;color:#fff;background:var(--bg)}
  .viewport-wrap{width:100%;height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
  .card{width:var(--card-width,720px);height:var(--card-height,520px);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(0,0,0,0.5);display:flex;flex-direction:column;overflow:hidden}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex:0 0 auto}
  h2{margin:0;font-size:16px}
  .small{font-size:12px;color:rgba(255,255,255,0.78)}
  .ad-player{width:100%;height:var(--ad-height,360px);border-radius:8px;overflow:hidden;background:#000;display:flex;align-items:center;justify-content:center;position:relative}
  .ad-player iframe, .ad-player video{width:100%;height:100%;border:0;object-fit:cover}
  .controls{margin-top:12px;display:flex;gap:8px;align-items:center;justify-content:center}
  .btn{padding:8px 10px;border-radius:8px;background:linear-gradient(45deg,var(--accent1),var(--accent2));border:none;color:#fff;cursor:pointer;font-weight:700}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .countdown{font-weight:700;font-size:18px;color:#fff}
  .note{margin-top:8px;color:rgba(255,255,255,0.6);font-size:12px;text-align:center}
  .hidden{display:none}
  #dbg{position:absolute;right:10px;bottom:10px;padding:6px 8px;background:rgba(0,0,0,0.6);border-radius:6px;font-size:11px;color:#fff;z-index:50;display:none}

  /* ===== Scoped AdSense landing styles (won't override existing rules) ===== */
  #gaingrid-adsense-landing{background:rgba(255,255,255,0.02);border-radius:8px;padding:12px;margin-bottom:10px;color:#fff}
  #gaingrid-adsense-landing h1{margin:0 0 6px;font-size:18px;line-height:1.05}
  #gaingrid-adsense-landing p{margin:6px 0;font-size:13px;color:rgba(255,255,255,0.92);max-width:880px;margin-left:auto;margin-right:auto}
  #gaingrid-adsense-landing h3{margin-top:10px;margin-bottom:6px;font-size:14px}
  #gaingrid-adsense-landing ul{list-style:none;padding:0;margin:6px 0 10px;display:inline-block;text-align:left}
  #gaingrid-adsense-landing ul li{margin:6px 0;font-size:13px}
  #gaingrid-adsense-landing .gg-cta{display:inline-block;margin-top:8px;padding:6px 12px;border-radius:8px;text-decoration:none;font-weight:700;background:linear-gradient(45deg,var(--accent1),var(--accent2));box-shadow:0 6px 16px rgba(0,0,0,0.25)}
  /* Ensure visible to crawlers even if JS toggles attributes */
  #gaingrid-adsense-landing[hidden]{display:block !important}
  /* Keep the landing compact to avoid breaking your fixed card height */
  #gaingrid-adsense-landing .wrap{max-height:110px;overflow:auto;padding-right:6px}
  @media (max-width:420px){ #gaingrid-adsense-landing h1{font-size:16px} #gaingrid-adsense-landing p{font-size:12px} }
</style>
</head>
<body>
  <div class="viewport-wrap">
    <div class="card" id="root">
      <div class="topbar">
        <div class="small">Hosted view</div>
        <div style="text-align:right">
          <div class="small" id="vipInfo">VIP: —</div>
        </div>
      </div>

      <div class="content" style="flex:1 1 auto;display:flex;flex-direction:column">
        <!-- ===== GAINGRID ADSENSE LANDING (visible in Public & Deeplink modes) ===== -->
        <section id="gaingrid-adsense-landing" aria-labelledby="gg-title" role="region">
          <div class="wrap">
            <h1 id="gg-title">Welcome to GainGrid</h1>
            <p>GainGrid is a Telegram-integrated platform that rewards users for engaging with ads, completing tasks, and playing fun games.</p>
            <p>Earn G-Coin, upgrade to VIP, and withdraw in USD, BTC, USDT, and more.</p>
            <h3>How it Works:</h3>
            <ul>
              <li>• Watch ads and earn G-Coin</li>
              <li>• Complete daily promotional tasks</li>
              <li>• Play games and get rewarded</li>
              <li>• Withdraw your earnings easily</li>
            </ul>
            <p><strong>Connect with our Telegram bot to get started!</strong></p>
            <p><a class="gg-cta" href="#app" role="button">Open GainGrid</a></p>
          </div>
          <noscript>
            <div style="margin-top:6px;font-size:12px;color:rgba(255,255,255,0.9);">The GainGrid app runs in your browser. If you don't see the app, please enable JavaScript.</div>
          </noscript>
        </section>
        <!-- ===== End landing content ===== -->

        <div id="adPlayer" class="ad-player" aria-live="polite">
          <div id="adPlaceholder" class="small">Ad player area</div>
        </div>

        <!-- Controls: hidden in public mode, visible only for deeplink payload -->
        <div id="controls" class="controls hidden" role="region" aria-label="Ad controls">
          <div class="countdown" id="countdown">—</div>
          <button id="claimBtn" class="btn" disabled>Claim / Send Result</button>
        </div>

        <div class="note" id="note" aria-hidden="false">Waiting for deeplink or public visit...</div>
      </div>

      <div id="dbg">dbg</div>
    </div>
  </div>

<script>
/* =========================
  Hosted HTML — dual-mode:
  - PUBLIC: show ad area only (AdSense -> custom provider iframe -> Adsterra -> fallback video)
  - DEEPLINK/HASH/POSTMESSAGE: authoritative payload, show countdown & claim, send results to BOT_WEBHOOK
  ========================= */

/* ===== CONFIG (edit only if needed) ===== */
const BOT_WEBHOOK = "https://gaingrid.bots.business/onWebhook"; // onWebhook receiver
const HOSTED_SESSION_KEY = 'gg_hosted_authoritative_payload';
const ADSTER_SCRIPT_KEY = 'a8702b8b4c48420a3815542007f1c0df';
const ADSTER_SCRIPT_SRC = "//www.highperformanceformat.com/" + ADSTER_SCRIPT_KEY + "/invoke.js";
const CUSTOM_PROVIDER_URL = "https://experiencedbat.com/dbm/F.zudZGMN/vBZ_GeUM/Jelm/9ruAZ/UjlGkpPiTuYT2/ORDok/w/NEjDU-t/Ntj/Y/4_OhTuAb2iNQixZWs/aKWn1rpydHDr0IxU";

/* ===== utilities (kept names) ===== */
const el = id => document.getElementById(id);
function dbg(msg){ try{ el('dbg').style.display='block'; el('dbg').textContent = String(msg).slice(0,140); console.log('hosted:', msg); }catch(e){} }
function nowISO(){ return (new Date()).toISOString(); }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function safeParse(s){ try{ return JSON.parse(s); }catch(e){ return null; } }

/* ===== decode helpers ===== */
function decodeBase64UrlSafe(raw){
  if(!raw) return null;
  try{
    let r = raw.replace(/\s+/g,'').replace(/-/g,'+').replace(/_/g,'/');
    const pad = r.length % 4;
    if(pad === 2) r += '=='; else if(pad === 3) r += '=';
    const dec = atob(r);
    try{ return JSON.parse(dec); }catch(e){ return dec; }
  }catch(e){ return null; }
}
function tryDecodePayloadString(raw){
  if(!raw) return null;
  try{
    // url-encoded JSON
    if((raw.indexOf('%7B') === 0 || raw.indexOf('%5B') === 0) || raw.indexOf('%22') !== -1){
      try { return JSON.parse(decodeURIComponent(raw)); } catch(e){}
    }
    // raw JSON
    if(raw[0] === '{' || raw[0] === '['){
      try { return JSON.parse(raw); } catch(e){}
    }
    // try base64
    const maybe = decodeBase64UrlSafe(raw);
    if(maybe) return maybe;
    try{ return JSON.parse(decodeURIComponent(raw)); }catch(e){}
  }catch(e){}
  return null;
}

/* ===== ad provider injection helpers ===== */
async function injectAdsense(holder){
  try{
    holder.innerHTML = '';
    const ins = document.createElement('ins');
    ins.className = 'adsbygoogle';
    ins.style.display = 'block';
    ins.style.width = '100%';
    ins.style.height = '100%';
    ins.setAttribute('data-ad-client', 'ca-pub-2309008538670900');
    ins.setAttribute('data-ad-slot', '4194843603');
    holder.appendChild(ins);
    try{ (adsbygoogle = window.adsbygoogle || []).push({}); }catch(e){}
    return true;
  }catch(e){ return false; }
}
function injectCustomProvider(holder){
  try{
    holder.innerHTML = '';
    const ifr = document.createElement('iframe');
    ifr.src = CUSTOM_PROVIDER_URL;
    ifr.style.border = '0';
    ifr.style.width = '100%';
    ifr.style.height = '100%';
    ifr.setAttribute('referrerpolicy','no-referrer');
    holder.appendChild(ifr);
    return true;
  }catch(e){ return false; }
}
function injectAdsterra(holder){
  try{
    holder.innerHTML = '';
    const wrap = document.createElement('div');
    wrap.style.width = '100%'; wrap.style.height = '100%'; wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.justifyContent='center';
    holder.appendChild(wrap);
    const s1 = document.createElement('script'); s1.type='text/javascript';
    s1.text = "atOptions = { 'key' : '" + ADSTER_SCRIPT_KEY + "', 'format' : 'iframe', 'height' : 60, 'width' : 468, 'params' : {} };";
    const s2 = document.createElement('script'); s2.type='text/javascript'; s2.src = ADSTER_SCRIPT_SRC;
    wrap.appendChild(s1); wrap.appendChild(s2);
    return true;
  }catch(e){ return false; }
}
function showFallbackVideo(holder){
  try{
    holder.innerHTML = '';
    const v = document.createElement('video');
    v.src = "https://storage.googleapis.com/interactive-media-ads/media/big_buck_bunny_trailer.mp4";
    v.autoplay = true; v.muted = true; v.playsInline = true; v.controls = false;
    v.style.width='100%'; v.style.height='100%';
    holder.appendChild(v);
    try{ v.play().catch(()=>{}); }catch(e){}
    return true;
  }catch(e){ return false; }
}

/* ===== core: start countdown & POST to webhook (deeplink mode only) ===== */
let countdownTimer = null;
let sessionActive = false;
let sessionCompleted = false;
let sessionPayload = null;

function startCountdownAndReport(authoritativePayload, source = 'deeplink'){
  try{
    if(!authoritativePayload || typeof authoritativePayload !== 'object') return;
    // store authoritative copy
    try{ sessionStorage.setItem(HOSTED_SESSION_KEY, JSON.stringify(authoritativePayload)); }catch(e){}
    sessionActive = true;
    sessionCompleted = false;
    sessionPayload = authoritativePayload;

    // determine secs
    const DURS = [30,40,50,60];
    const secs = Number(authoritativePayload.secs) || randChoice(DURS);
    const ad_id = authoritativePayload.ad_id || authoritativePayload.id || ('host_ad_' + Date.now());
    const reward = authoritativePayload.reward || authoritativePayload.r || authoritativePayload.base || 0;

    // show controls
    el('controls').classList.remove('hidden');
    el('gaingrid-adsense-landing').style.display = 'none';
    el('note').textContent = `Ad: ${ad_id} — running ${secs}s`;
    el('countdown').textContent = secs;
    el('claimBtn').disabled = true;

    // show VIP if present
    try{ if(authoritativePayload.vip_level) el('vipInfo').textContent = 'VIP: ' + authoritativePayload.vip_level; }catch(e){}

    // ensure ad provider visible (prefer AdSense -> custom -> adsterra -> video)
    (async ()=>{
      const holder = el('adPlayer');
      let ok = false;
      try { ok = await injectAdsense(holder); } catch(e) { ok = false; }
      if(!ok) ok = injectCustomProvider(holder);
      if(!ok) ok = injectAdsterra(holder);
      if(!ok) showFallbackVideo(holder);
    })();

    // countdown
    let remaining = secs;
    if(countdownTimer) clearInterval(countdownTimer);
    countdownTimer = setInterval(()=>{
      remaining--;
      el('countdown').textContent = remaining;
      if(remaining <= 0){
        clearInterval(countdownTimer);
        countdownTimer = null;
        sessionCompleted = true;
        sessionActive = false;
        el('claimBtn').disabled = false;
        el('note').textContent = 'Countdown finished — result posted to webhook.';
        // prepare result payload
        const result = {
          ad_id: ad_id,
          reward: reward,
          base: authoritativePayload.base || 0,
          vip_level: authoritativePayload.vip_level || authoritativePayload.vip || null,
          user: authoritativePayload.user || authoritativePayload.user_id || null,
          status: 'completed',
          ts: nowISO(),
          original_payload: authoritativePayload
        };
        // send automatically
        sendToWebhook(result);
      }
    }, 1000);

    // manual claim
    el('claimBtn').onclick = function(){
      // manual claim allowed after countdown
      if(el('claimBtn').disabled) return;
      el('claimBtn').disabled = true;
      sessionCompleted = true;
      sessionActive = false;
      const result = {
        ad_id: ad_id,
        reward: reward,
        base: authoritativePayload.base || 0,
        vip_level: authoritativePayload.vip_level || authoritativePayload.vip || null,
        user: authoritativePayload.user || authoritativePayload.user_id || null,
        status: 'claimed_manual',
        ts: nowISO(),
        original_payload: authoritativePayload
      };
      sendToWebhook(result);
    };

  }catch(e){ console.warn('startCountdownAndReport err', e); dbg('count err'); }
}

/* ===== send to onWebhook (keepalive) ===== */
function sendToWebhook(data){
  try{
    const wrapper = { action: 'ads_validate', payload: data, meta: { ts: Date.now(), host: location.href } };
    const body = JSON.stringify(wrapper);
    let sent = false;
    try{
      if(navigator.sendBeacon){
        const blob = new Blob([body], { type: 'application/json' });
        sent = navigator.sendBeacon(BOT_WEBHOOK, blob);
      }
    }catch(e){ sent = false; }
    if(!sent){
      fetch(BOT_WEBHOOK, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: body, keepalive:true })
        .then(()=>{}).catch(()=>{});
    }
    dbg('webhook sent: ' + (data.status||''));
    el('note').textContent = 'Result posted to webhook.';
    // leave page open — parent can close iframe if desired
  }catch(e){ console.warn('sendToWebhook err', e); dbg('webhook err'); el('note').textContent = 'Failed to post result'; }
}

/* ===== skip/abort detection: alert webhook if user navigates/close early ===== */
function finalizeAsSkippedIfActive(reason){
  try{
    if(!sessionActive || sessionCompleted) return;
    sessionActive = false;
    sessionCompleted = false;
    // prepare skipped payload
    const ad_id = sessionPayload && (sessionPayload.ad_id || sessionPayload.id) ? (sessionPayload.ad_id || sessionPayload.id) : ('host_ad_' + Date.now());
    const reward = sessionPayload && (sessionPayload.reward || sessionPayload.base) ? (sessionPayload.reward || sessionPayload.base) : 0;
    const result = {
      ad_id: ad_id,
      reward: reward,
      base: sessionPayload && sessionPayload.base || 0,
      vip_level: sessionPayload && (sessionPayload.vip_level || sessionPayload.vip) || null,
      user: sessionPayload && (sessionPayload.user || sessionPayload.user_id) || null,
      status: 'skipped',
      reason: reason || 'user_navigated_or_closed',
      ts: nowISO(),
      original_payload: sessionPayload || null
    };
    sendToWebhook(result);
  }catch(e){ console.warn('finalizeAsSkippedIfActive err', e); }
}

// beforeunload: try to inform parent/bot that user skipped if countdown still running
window.addEventListener('beforeunload', function(ev){
  try{
    finalizeAsSkippedIfActive('beforeunload');
  }catch(e){}
});

// visibilitychange: if tab becomes hidden and session active for a short time, attempt to mark skipped
document.addEventListener('visibilitychange', function(){
  try{
    if(document.visibilityState === 'hidden'){
      // schedule a short delay — host might just be switching focus
      setTimeout(()=> {
        if(document.visibilityState === 'hidden'){
          finalizeAsSkippedIfActive('visibility_hidden');
        }
      }, 1200);
    }
  }catch(e){}
});

/* ===== decode incoming payloads (query start / hash / hash path) ===== */
function getQueryParams(){
  const s = location.search.replace(/^\?/,''); if(!s) return {};
  return s.split('&').filter(Boolean).map(p=>{ const i=p.indexOf('='); if(i<0) return [decodeURIComponent(p),'']; return [decodeURIComponent(p.slice(0,i)), decodeURIComponent(p.slice(i+1))]; }).reduce((o,[k,v])=>{ o[k]=v; return o; }, {});
}

/* ===== postMessage listener so parent iframe can send authoritative payload directly ===== */
window.addEventListener('message', function(ev){
  try{
    // Accept messages from any origin (gain.web may use different origin) — do not block for now
    const d = ev.data || {};
    if(!d || typeof d !== 'object') return;
    // expected: { type: 'start_payload', payload: { ... } }
    if(d.type === 'start_payload' && d.payload){
      const payload = d.payload;
      // Accept if object or string (string may be base64/json)
      let obj = null;
      if(typeof payload === 'string') obj = tryDecodePayloadString(payload);
      else obj = payload;
      if(obj && typeof obj === 'object'){
        el('note').textContent = 'PostMessage payload received.';
        startCountdownAndReport(obj, 'postmessage');
      }
      return;
    }
    // optional: handle hosted commands
    if(d.type === 'close_hosted'){
      try{ window.close(); }catch(e){}
      return;
    }
  }catch(e){ console.warn('message handler err', e); }
}, false);

/* ===== boot: check query/hash then public mode ===== */
function boot(){
  try{
    // 1) query ?start=
    const qp = getQueryParams();
    if(qp.start){
      const decoded = tryDecodePayloadString(qp.start);
      if(decoded && typeof decoded === 'object'){
        el('note').textContent = 'Deeplink payload received.';
        startCountdownAndReport(decoded);
        return;
      }
    }

    // 2) hash-based
    const hraw = (location.hash || '').replace(/^#/,'');
    if(hraw){
      // path-like: #/ad?ad_id=...
      if(hraw.startsWith('/')){
        const parts = hraw.split('?'); const path = parts[0].replace(/^\//,'');
        const hashQP = {};
        if(parts[1]) parts[1].split('&').forEach(p=>{ const i=p.indexOf('='); if(i>=0) hashQP[decodeURIComponent(p.slice(0,i))]=decodeURIComponent(p.slice(i+1)); else hashQP[decodeURIComponent(p)]= ''; });
        if(path === 'ad' && (hashQP.ad_id || hashQP.id || hashQP.start)){
          // if start param exists and is base64/json use it
          if(hashQP.start){
            const dec = tryDecodePayloadString(hashQP.start);
            if(dec && typeof dec === 'object'){ el('note').textContent = 'Hash path payload (start) received.'; startCountdownAndReport(dec); return; }
          }
          const payload = { ad_id: hashQP.ad_id || hashQP.id, secs: hashQP.secs || hashQP.duration, reward: hashQP.reward || hashQP.base, user: { user_id: hashQP.user_id || hashQP.uid || null } };
          el('note').textContent = 'Hash path payload received.';
          startCountdownAndReport(payload);
          return;
        }
      } else {
        // pure hash could be base64 or urlencoded JSON
        const decoded = tryDecodePayloadString(decodeURIComponent(hraw));
        if(decoded && typeof decoded === 'object'){
          el('note').textContent = 'Hash base64 payload received.';
          startCountdownAndReport(decoded);
          return;
        }
      }
    }

    // 3) sessionStorage fallback
    try{
      const sess = sessionStorage.getItem(HOSTED_SESSION_KEY);
      if(sess){
        const obj = safeParse(sess);
        if(obj && typeof obj === 'object'){
          // if session exists but no active countdown, we still can resume UI in completed/idle state
          el('note').textContent = 'Resumed session (no active countdown).';
          // do not auto-start if not authoritative now — leave as public mode
        }
      }
    }catch(e){}

    // no authoritative payload => PUBLIC MODE
    el('note').textContent = 'Public mode — ad area (no controls).';
    el('controls').classList.add('hidden');
    // show ad area: prefer AdSense -> custom provider -> Adsterra -> fallback video
    (async ()=>{
      const holder = el('adPlayer');
      let ok = false;
      try { ok = await injectAdsense(holder); } catch(e) { ok = false; }
      if(!ok) ok = injectCustomProvider(holder);
      if(!ok) ok = injectAdsterra(holder);
      if(!ok) showFallbackVideo(holder);
    })();

  }catch(e){ console.warn('boot err', e); dbg('boot err'); }
}

/* run */
boot();

</script>
</body>
</html>