<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>GainGrid Hosted — Tasks & Ads (iframe-ready)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

<!-- AdSense (kept visible for review) -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2309008538670900"
     crossorigin="anonymous"></script>

<style>
  :root{
    --accent1:#ff6b9d; --accent2:#c471ed;
    --bg:linear-gradient(135deg,#0f1419 0,#1a2332 50%,#0d1117 100%);
  }
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;color:#fff;background:var(--bg)}
  .viewport-wrap{width:100%;height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
  .card{width:var(--card-width,420px);height:var(--card-height,620px);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(0,0,0,0.5);display:flex;flex-direction:column;overflow:hidden}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex:0 0 auto}
  .back-btn{background:transparent;border:0;color:rgba(255,255,255,0.9);cursor:pointer;font-weight:700}
  h2{margin:0;font-size:16px}
  .small{font-size:12px;color:rgba(255,255,255,0.78)}
  .btn{padding:8px 10px;border-radius:8px;background:linear-gradient(45deg,var(--accent1),var(--accent2));border:none;color:#fff;cursor:pointer;font-weight:700}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .content{flex:1 1 auto;overflow:hidden;display:flex;flex-direction:column}
  .task-list{display:flex;flex-direction:column;gap:10px;margin:8px 0;overflow:auto;padding-right:6px}
  .card-item{width:100%;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:space-between;gap:12px;min-height:56px;}
  .ad-player{width:100%;height:var(--ad-height,260px);border-radius:8px;overflow:hidden;background:#000;display:flex;align-items:center;justify-content:center;position:relative;margin-top:12px}
  .note{margin-top:8px;color:rgba(255,255,255,0.6);font-size:12px}
  .countdown{font-weight:700;font-size:18px;color:#fff}
  .hidden{display:none}
  #adPlayerAdsenseHolder, #taskBanner, #adsterBannerHolder{display:flex;justify-content:center;align-items:center}
  .dbg{position:absolute;left:8px;bottom:8px;padding:6px 8px;background:rgba(0,0,0,0.6);border-radius:6px;font-size:11px;color:#fff;z-index:50;display:none}
  .dbg.dbg-visible{display:block}
  .landing-buttons{display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center;margin-top:8px}
  .gaingrid-verified{color:lightgreen;margin-top:6px;font-weight:600;font-size:12px}
</style>
</head>
<body>
  <div class="viewport-wrap">
    <div class="card" id="root">
      <div class="topbar">
        <button id="backBtn" class="back-btn">← Back</button>
        <div style="text-align:right">
          <div class="small" id="vipInfo">VIP: —</div>
        </div>
      </div>

      <div class="content">
        <div id="main" class="small">Initializing…</div>
      </div>

      <div class="dbg" id="hostedDbg">hosted:init</div>
    </div>
  </div>

<script>
/* ============================
   Hosted: Public + Gain.Web integration
   - hash/postMessage/start param handling
   - authoritative payload stored at 'gg_hosted_authoritative_payload'
   - posts 'hosted_ready' and 'ad_complete' to parent
   - posts to BOT webhook on deeplink/direct calls
   ============================ */

/* ---------- CONFIG ---------- */
const HOSTED_ORIGIN = "https://swanybz.github.io/"; // keep same domain (used by parent)
const HOSTED_BASE = HOSTED_ORIGIN + "#";
const BOT_WEBHOOK = "https://gaingrid.bots.business/onWebhook"; // deeplink/direct webhook (change if needed)
const ADSENSE_CLIENT = "ca-pub-2309008538670900";
const AD_DURATIONS = [30,40,50,60];
const KEY_AUTH = 'gg_hosted_authoritative_payload';
const KEY_PROFILE = 'gg_hosted_profile';

/* ---------- small utilities ---------- */
const el = id => document.getElementById(id);
function logd(){ try{ if(window.console && console.log) console.log.apply(console, ['hosted:', ...arguments]); if(el('hostedDbg')) el('hostedDbg').textContent = String(arguments[0]).slice(0,30); }catch(e){} }
function setMain(html){ if(el('main')) el('main').innerHTML = html; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function escapeHtml(s){ if(!s && s!==0) return ''; return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ---------- profile apply ---------- */
let profile = null;
function applyUserData(u){
  try{
    if(!u) return;
    profile = Object.assign({}, profile || {}, u);
    if(el('vipInfo')) el('vipInfo').textContent = profile.vip_level ? ('VIP: ' + profile.vip_level) : 'VIP: —';
    if(el('hostedDbg')) el('hostedDbg').textContent = 'hosted:profile';
    try{ sessionStorage.setItem(KEY_PROFILE, JSON.stringify(profile)); }catch(e){}
  }catch(e){ console.warn('applyUserData err', e); }
}

/* ---------- helper: decode base64/hash payload ---------- */
function tryDecodePayloadString(raw){
  if(!raw) return null;
  try {
    // URL-encoded JSON first
    if(raw.indexOf('%7B') === 0 || raw.indexOf('%5B') === 0 || raw.indexOf('%22') !== -1){
      try { return JSON.parse(decodeURIComponent(raw)); } catch(e){}
    }
    // Normalize URL-safe base64
    let norm = raw.replace(/\s+/g,'').replace(/-/g,'+').replace(/_/g,'/');
    const pad = norm.length % 4;
    if(pad === 2) norm += '=='; else if(pad === 3) norm += '=';
    let decoded = null;
    try { decoded = atob(norm); } catch(e){ decoded = null; }
    if(!decoded) try { decoded = decodeURIComponent(raw); } catch(e){ decoded = raw; }
    try { return JSON.parse(decoded); } catch(e){ return decoded; }
  } catch(err){ console.warn('tryDecodePayloadString err', err); return null; }
}

/* ---------- parse search query into object ---------- */
function parseQP(qs){ if(!qs) return {}; return qs.replace(/^\?/,'').split('&').filter(Boolean).reduce((o,p)=>{ const i=p.indexOf('='); if(i<0) o[decodeURIComponent(p)]=''; else o[decodeURIComponent(p.slice(0,i))]=decodeURIComponent(p.slice(i+1)); return o; }, {}); }

/* ---------- parse hash route: supports:
     - #/ad?id=...&secs=...  (path style)
     - #/task?id=...&secs=...
     - #<base64payload>      (legacy base64-in-hash)
  ---------- */
function parseHashRoute(){
  const rawHash = (location.hash || '').replace(/^#/,'');
  if(!rawHash) return null;

  // if hash looks like '/ad?...' or '/task?...'
  if(rawHash.startsWith('/')){
    const parts = rawHash.split('?');
    const path = parts[0].toLowerCase(); // '/ad' or '/task' or '/adview'
    const qs = parts[1] || '';
    const obj = parseQP(qs);
    return { mode: 'route', path, qp: obj };
  }

  // if it is a base64 payload (no '=' or '&' querylike)
  if(rawHash.indexOf('=') === -1 && rawHash.indexOf('&') === -1 && rawHash.indexOf('?') !== 0){
    const decoded = tryDecodePayloadString(decodeURIComponent(rawHash));
    if(decoded) return { mode: 'payload', payload: decoded };
  }

  // fallback: attempt QS-style parse
  return null;
}

/* ---------- central payload processor ---------- */
function processStartPayload(payload){
  try{
    if(!payload || typeof payload !== 'object') return;
    // store authoritative copy
    try{ sessionStorage.setItem(KEY_AUTH, JSON.stringify(payload)); }catch(e){}
    // apply profile if present
    if(payload.user && typeof payload.user === 'object') applyUserData(payload.user);
    else if(payload.profile) applyUserData(payload.profile);
    // tasks array
    if(Array.isArray(payload.tasks) && payload.tasks.length){
      PARENT_TASKS = payload.tasks.map(t => ({ id: t.id || t.task_id, title: t.title || t.name, secs: t.secs||t.duration||30, reward: t.reward||t.base||0, url: t.url||t.link||'' }));
      renderTasksFromParent(PARENT_TASKS);
      return;
    }
    // ad open
    if(payload.ad_id || payload.id || payload.type === 'ad' || payload.isAd){
      const ad = {
        ad_id: payload.ad_id || payload.id,
        secs: Number(payload.secs || payload.s || payload.duration) || null,
        reward: Number(payload.reward || payload.r || payload.base) || null,
        vip_level: payload.vip_level || payload.vip || null,
        user: payload.user || payload
      };
      try{ sessionStorage.setItem('gg_hosted_last_ad_payload', JSON.stringify(ad)); }catch(e){}
      renderAdFlow({ ad_id: ad.ad_id, secs: ad.secs, reward: ad.reward, vip: ad.vip_level, user: ad.user });
      return;
    }
    // otherwise show landing message
    setMain('<div class="small">Payload received and stored. Use UI to start ad/task.</div>');
  }catch(e){ console.warn('processStartPayload err', e); }
}

/* ---------- parse hash payload on boot (handles both base64 payload and route) ---------- */
(function parseHashOnBootAndRoute(){
  try {
    const p = parseHashRoute();
    if(!p) return;
    if(p.mode === 'payload' && p.payload && typeof p.payload === 'object'){
      processStartPayload(p.payload);
      return;
    }
    if(p.mode === 'route'){
      // route detection for /ad and /task
      const path = p.path || '';
      const qp = p.qp || {};
      if(path.startsWith('/ad')){
        // route to ad with qp params
        const ad_id = qp.ad_id || qp.id || qp.ad || null;
        const secs = qp.secs || qp.s || qp.duration || null;
        const reward = qp.reward || qp.r || qp.base || null;
        // create normalized payload and process
        processStartPayload({ ad_id, secs: secs ? Number(secs) : undefined, reward: reward ? Number(reward) : undefined, vip: qp.vip || qp.vip_level || undefined, user: qp.user ? tryDecodePayloadString(qp.user) : undefined });
        return;
      } else if(path.startsWith('/task')){
        const task_id = qp.task_id || qp.id || null;
        const secs = qp.secs || qp.s || qp.duration || null;
        const reward = qp.reward || qp.r || qp.base || null;
        processStartPayload({ task_id, secs: secs ? Number(secs) : undefined, reward: reward ? Number(reward) : undefined, _source:'route' });
        return;
      }
    }
  } catch(e){ console.warn('parseHashOnBootAndRoute err', e); }
})();

/* ---------- message queueing & handshake ---------- */
window.__HOSTED_INCOMING_QUEUE = window.__HOSTED_INCOMING_QUEUE || [];
window.__HOSTED_IS_READY = false;

window.addEventListener('message', function __earlyHostQueue(ev){
  try{
    const d = ev && ev.data;
    if(!d) return;
    // ping
    if(d.type === 'ping_hosted'){
      try{ (ev.source && ev.source.postMessage) && ev.source.postMessage({ type: 'hosted_pong', payload:{ ts: Date.now() } }, '*'); }catch(e){}
      return;
    }
    // normalize start payload / open_task / open_ad
    if(d.type === 'start_payload' || d.type === 'open_task' || d.type === 'open_ad'){
      let normalized = { type:'start_payload', payload:{} };
      if(d.type === 'start_payload') normalized = d;
      else normalized.payload = d.payload || d;
      if(!window.__HOSTED_IS_READY){
        window.__HOSTED_INCOMING_QUEUE.push(normalized);
        return;
      }
      processStartPayload(normalized.payload || {});
      return;
    }
    if(!window.__HOSTED_IS_READY){
      window.__HOSTED_INCOMING_QUEUE.push(d);
      return;
    }
  }catch(err){ console.warn('earlyHostQueue err', err); }
}, false);

function postParent(msg){
  try{ if(window.parent && window.parent !== window) window.parent.postMessage(msg, '*'); }catch(e){}
  try{ if(window.opener && !window.opener.closed) window.opener.postMessage(msg, '*'); }catch(e){}
  logd('postParent', msg.type || msg);
}

/* consume queued messages */
function _consumeQueuedMessages(){
  try{
    while(window.__HOSTED_INCOMING_QUEUE && window.__HOSTED_INCOMING_QUEUE.length){
      const msg = window.__HOSTED_INCOMING_QUEUE.shift();
      if(!msg) continue;
      if(msg.type === 'start_payload') processStartPayload(msg.payload || {});
      else {
        try{ window.dispatchEvent(new MessageEvent('message', { data: msg })); }catch(e){}
      }
    }
  }catch(e){ console.warn('consume queue error', e); }
}

/* announce ready (handshake) */
function announceReady(){
  try{
    window.__HOSTED_IS_READY = true;
    _consumeQueuedMessages();
    // include ad_id if present
    let auth = null;
    try { auth = JSON.parse(sessionStorage.getItem(KEY_AUTH) || 'null'); } catch(e){ auth = null; }
    const payload = { ts: Date.now() };
    if(auth && (auth.ad_id || auth.id)) payload.ad_id = (auth.ad_id || auth.id);
    postParent({ type: 'hosted_ready', payload });
    if(el('hostedDbg')) el('hostedDbg').textContent = 'hosted:ready' + (payload.ad_id ? ' ad:' + payload.ad_id : '');
    logd('announceReady', payload);
  }catch(e){ console.warn('announceReady failed', e); }
}
if(document.readyState === 'complete' || document.readyState === 'interactive') setTimeout(announceReady, 60);
else document.addEventListener('DOMContentLoaded', ()=> setTimeout(announceReady, 60));

/* ---------- global message handler ---------- */
window.addEventListener('message', function(ev){
  try{
    const d = ev.data || {};
    if(!d || typeof d !== 'object') return;
    logd('msg', d.type);
    if(d.type === 'profile_response' && d.payload){ applyUserData(d.payload); return; }
    if(d.type === 'start_payload' && d.payload){ processStartPayload(d.payload); return; }
    if(d.type === 'open_ad' && d.payload && d.payload.ad_id){
      try{ sessionStorage.setItem(KEY_AUTH, JSON.stringify(d.payload)); }catch(e){}
      renderAdFlow({ ad_id: d.payload.ad_id, secs: d.payload.secs, reward: d.payload.reward, vip: d.payload.vip, user: d.payload.user });
      return;
    }
    if(d.type === 'open_task' && d.payload && d.payload.task_id){
      try{ sessionStorage.setItem(KEY_AUTH, JSON.stringify(d.payload)); }catch(e){}
      awaitRunTaskFlowFromPayload(d.payload);
      return;
    }
    if(d.type === 'close_hosted' || d.type === 'request_close'){
      try{ if(window.close) window.close(); }catch(e){}
      return;
    }
  }catch(e){ console.warn('hosted message err', e); }
});

/* ---------- public landing UI (AdSense visible) ---------- */
function showPublicLanding(){
  setMain(`<div style="text-align:center">
    <h2 style="margin:0 0 6px 0">GainGrid — Public Preview</h2>
    <div class="small">Open demo for AdSense & testers. Choose a section:</div>
    <div class="landing-buttons">
      <button id="landingTasks" class="btn big">🧾 Task Board</button>
      <button id="landingAds" class="btn big">🎥 Ads Center</button>
    </div>
    <div style="margin-top:12px;text-align:center">
      <div id="adPlayerAdsenseHolder" style="margin:8px auto;max-width:468px">
        <ins class="adsbygoogle"
             style="display:inline-block;width:468px;height:60px"
             data-ad-client="${ADSENSE_CLIENT}"
             data-ad-slot="4194843603"></ins>
      </div>
      <div class="small" style="margin-top:8px">Ads preview area — GainsGrid public mode</div>
    </div>
  </div>`);
  try{ (adsbygoogle = window.adsbygoogle || []).push({}); }catch(e){}
  setTimeout(()=>{
    const lt = el('landingTasks'), la = el('landingAds');
    if(lt) lt.addEventListener('click', ()=> { routerTo('task'); });
    if(la) la.addEventListener('click', ()=> { routerTo('ad'); });
  },40);
}

/* ---------- router helpers ---------- */
function routerTo(section){
  if(section === 'ad') renderAdFlow({});
  else if(section === 'task') renderTaskBoard({});
}

/* ---------- task board minimal ---------- */
let PARENT_TASKS = null;
async function renderTasksFromParent(tasks){
  try{
    PARENT_TASKS = Array.isArray(tasks) ? tasks.slice() : [];
    if(!PARENT_TASKS.length){ setMain(`<div class="small">No tasks provided by parent.</div>`); return; }
    const html = PARENT_TASKS.map(t=>{
      const id = t.id || t.task_id || ('task_' + Math.random().toString(36).slice(2,8));
      return `<div class="card-item" role="article" data-task-id="${id}">
        <div class="left"><strong>${escapeHtml(t.title||t.name||('Task ' + id))}</strong><div class="meta small">${(t.secs||30)}s · Reward ${t.reward||0} G</div></div>
        <div style="flex-shrink:0"><button class="btn do-task" data-id="${encodeURIComponent(id)}">Do</button></div>
      </div>`;
    }).join('');
    setMain(`<div class="small">Tasks provided by parent</div><div class="task-list">${html}</div>`);
    Array.from(document.querySelectorAll('.do-task')).forEach(b=>{
      b.addEventListener('click', ()=> {
        const id = decodeURIComponent(b.getAttribute('data-id'));
        const match = (PARENT_TASKS||[]).find(t=> (t.id || t.task_id) === id);
        if(match) awaitRunTaskFlowFromPayload({ task_id: id, secs: match.secs || 30, reward: match.reward || 0, url: match.url || '' });
      });
    });
  }catch(e){ console.warn('renderTasksFromParent', e); setMain('<div class="small">Unable to render tasks.</div>'); }
}

/* ---------- runTaskFlow (kept simple) ---------- */
async function awaitRunTaskFlowFromPayload(p){
  try{
    const id = p.task_id || p.id || ('task_' + Math.random().toString(36).slice(2,8));
    const secs = Number(p.secs || p.duration || 30);
    const reward = Number(p.reward || p.base || 0);
    const url = p.url || p.link || '';
    setTimeout(()=> { try{ runTaskFlow({ task_id: id, url, secs, rewardBase: reward, reward: reward, _source:'ui' }); }catch(e){ console.warn('runTaskFlow err', e); } }, 10);
  }catch(e){ console.warn('awaitRunTaskFlowFromPayload', e); }
}
async function runTaskFlow(opts){
  setMain(`<div class="small">Task ${escapeHtml(opts.task_id||'')} — open target and stay ${opts.secs||30}s.</div>
    <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><button id="openBtn" class="btn">Open & Start</button><button id="cancelBtn" class="btn ghost">Cancel</button></div>
    <div id="taskNote" class="small" style="margin-top:12px"></div>`);
  const openBtn = el('openBtn'), cancelBtn = el('cancelBtn'), note = el('taskNote');
  let finished=false, expectedEnd=null, popup=null;
  function finalize(){
    if(finished) return;
    finished = true;
    const payload = { task_id: opts.task_id, reward: opts.reward || 0, vip_level: (profile && profile.vip_level) || null, user_id: (profile && profile.user_id) || null, status:'completed' };
    postParent({ type:'task_complete', payload });
    postParent({ type:'task_verified', payload });
    setMain('<div class="small">Task verified. Returning...</div>');
    try{ sessionStorage.removeItem(KEY_AUTH); sessionStorage.removeItem(KEY_PROFILE); }catch(e){}
    setTimeout(()=> { postParent({ type:'close_hosted', reason:'task_done', payload }); try{ if(window.close) window.close(); }catch(e){} }, 700);
  }
  openBtn.addEventListener('click', ()=>{
    cancelBtn.style.display='none'; openBtn.disabled=true; note.textContent = `Opening — please remain ${opts.secs}s...`;
    expectedEnd = Date.now() + (opts.secs||30)*1000;
    try{ popup = window.open(opts.url || '#', '_blank', 'noopener'); }catch(e){ popup=null; }
    if(popup){
      const poll = setInterval(()=> {
        try{
          if(popup.closed && !finished){
            clearInterval(poll);
            if(Date.now() < expectedEnd){
              finished = true;
              postParent({ type:'task_complete', payload: { task_id: opts.task_id, status:'unverified_popup_closed' } });
              setMain('<div class="small">Popup closed too early. Returning...</div>');
              setTimeout(()=> postParent({ type:'close_hosted', reason:'popup_closed' }),700);
            } else finalize();
          }
        }catch(e){}
      },700);
    } else {
      // fallback timer
      setTimeout(()=> finalize(), (opts.secs||30)*1000 + 3000);
    }
  });
  cancelBtn.addEventListener('click', ()=> { postParent({ type:'task_skipped', payload:{ task_id: opts.task_id } }); routerTo('task'); });
  window.addEventListener('beforeunload', ()=> { if(!finished) postParent({ type:'task_incomplete', payload:{ task_id: opts.task_id } }); });
}

/* ---------- AD FLOW (core) ---------- */
let adTick = null;
async function renderAdFlow(qp){
  try{
    // authoritative payload first
    let auth = null;
    try{ auth = JSON.parse(sessionStorage.getItem(KEY_AUTH) || 'null'); }catch(e){ auth = null; }
    const combined = Object.assign({}, auth || {}, qp || {});
    // determine properties
    const ad_id = combined.ad_id || combined.id || ('host_ad_' + Date.now());
    const secs = Number(combined.secs || combined.duration) || (combined.secs===0?0: AD_DURATIONS[Math.floor(Math.random()*AD_DURATIONS.length)]);
    const reward = (combined.reward || combined.r || combined.base) || 0;
    const vip_level = combined.vip || combined.vip_level || (profile && profile.vip_level) || 'none';
    const user = combined.user || (profile && profile) || null;

    // save last ad payload
    try{ sessionStorage.setItem('gg_hosted_last_ad_payload', JSON.stringify({ ad_id, secs, reward, vip_level, user })); }catch(e){}

    // build UI
    setMain(`<div class="small">Watching: <strong>${escapeHtml(ad_id)}</strong> — Reward: <strong>${reward} G</strong>
      <div class="small">(${secs}s · VIP: ${escapeHtml(vip_level||'none')})</div></div>
      <div class="ad-player" id="adPlayerNode"><div class="small">Ad player area (demo)</div></div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><div class="countdown" id="adCount">${secs}</div></div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center"><button id="claimBtn" class="btn" disabled>Claim</button><button id="retBtn" class="btn ghost hidden">Close</button></div>
      <div id="adNote" class="note">Auto-completes after ${secs}s</div>`);

    try{ (adsbygoogle = window.adsbygoogle || []).push({}); }catch(e){}

    // notify parent that hosted is open/ready for this ad
    postParent({ type:'hosted_ready', payload: { ts: Date.now(), ad_id } });

    // start countdown and behavior
    const countEl = el('adCount'), claimBtn = el('claimBtn'), retBtn = el('retBtn'), adNote = el('adNote');
    let remaining = Number(secs);
    if(countEl) countEl.textContent = remaining;

    if(adTick) clearInterval(adTick);
    adTick = setInterval(()=>{
      remaining--;
      if(countEl) countEl.textContent = remaining;
      if(remaining <= 0){
        clearInterval(adTick);
        if(claimBtn) claimBtn.disabled = false;
        adNote.textContent = 'Ad finished. Sending result...';

        const payload = {
          ad_id,
          reward,
          base: reward,
          vip_bonus: 0,
          vip_level,
          user_id: (user && (user.user_id || user.id)) || null,
          user: user || null,
          status: 'completed',
          meta: { ts: Date.now(), source: 'hosted' }
        };

        // send to parent
        try{ postParent({ type:'ad_complete', payload }); }catch(e){ console.warn('postParent ad_complete failed'); }

        // If opened directly via deeplink/start param (no parent), send webhook to bot
        const isStandalone = (window.parent === window);
        if(isStandalone){
          try{ sendWebhook({ action:'ads_validate', payload }); }catch(e){ console.warn('webhook send failed', e); }
        }

        // show close button
        if(retBtn){ retBtn.classList.remove('hidden'); retBtn.textContent = (isStandalone ? 'Close' : 'Return'); }
        // request close after short delay
        setTimeout(()=> { postParent({ type:'close_hosted', reason:'ad_done', payload }); }, 900);
      }
    }, 1000);

    // claim button (manual)
    if(claimBtn) claimBtn.addEventListener('click', ()=>{
      if(claimBtn.disabled) return;
      claimBtn.disabled = true;
      const payload = { ad_id, reward, vip_level, user_id: (user && (user.user_id||user.id)) || null, status:'claimed', meta:{ts:Date.now()} };
      postParent({ type:'ad_complete', payload });
      const isStandalone = (window.parent === window);
      if(isStandalone) try{ sendWebhook({ action:'ads_validate', payload }); }catch(e){ console.warn('webhook claim failed', e); }
      try{ sessionStorage.removeItem(KEY_AUTH); sessionStorage.removeItem(KEY_PROFILE); }catch(e){}
      if(retBtn) retBtn.classList.remove('hidden');
    });

    if(retBtn) retBtn.addEventListener('click', ()=> {
      postParent({ type:'close_hosted', reason:'user_return' });
      try{ if(window.close) window.close(); }catch(e){}
    });

  }catch(e){ console.warn('renderAdFlow err', e); setMain('<div class="small">Unable to start ad view.</div>'); }
}

/* ---------- send webhook to bot (deeplink/direct) ---------- */
async function sendWebhook(data){
  try{
    // Accept object with { action, payload } OR raw payload (wrap)
    const body = (data && data.action) ? data : { action: 'ads_validate', payload: data || {} };
    // Prefer webhook URL from authoritative payload if present
    let candidates = [BOT_WEBHOOK];
    try{
      const auth = JSON.parse(sessionStorage.getItem(KEY_AUTH) || 'null');
      if(auth && auth.webhook) candidates.unshift(auth.webhook);
    }catch(e){}
    // also check query param ?webhook=
    try{
      const qp = parseQP(location.search || '');
      if(qp.webhook) candidates.unshift(qp.webhook);
    }catch(e){}
    const url = candidates.find(Boolean);
    if(!url) return console.warn('no webhook available');
    await fetch(url, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(body), keepalive: true });
    logd('webhook posted to', url);
  }catch(e){ console.warn('sendWebhook failed', e); }
}

/* ---------- router (start param / default landing) ---------- */
function decodeStart(raw){
  if(!raw) return null;
  try{ const norm = raw.replace(/-/g,'+').replace(/_/g,'/'); const json = atob(norm); return JSON.parse(json); }catch(e){ try{ return JSON.parse(decodeURIComponent(raw)); }catch(e){ return null; } }
}

async function router(){
  try{
    // check query param start
    const qp = parseQP(location.search || '');
    if(qp.start){
      const decoded = decodeStart(qp.start);
      if(decoded){ processStartPayload(decoded); return; }
    }

    // If hash route contains '/ad' or '/task' or base64 payload, parseHashOnBootAndRoute already handled it on boot.
    // If authoritative payload exists in sessionStorage -> automatically render ad/task if present
    const auth = (function(){ try{ return JSON.parse(sessionStorage.getItem(KEY_AUTH)||'null'); }catch(e){return null;} })();
    if(auth){
      if(auth.ad_id) { renderAdFlow(auth); return; }
      if(auth.task_id || auth.tasks) { if(auth.tasks) PARENT_TASKS = auth.tasks; if(auth.task_id) awaitRunTaskFlowFromPayload(auth); else renderTasksFromParent(PARENT_TASKS||[]); return; }
    }
    // default: public landing
    showPublicLanding();
  }catch(e){ console.warn('router err', e); showPublicLanding(); }
}

/* ---------- boot ---------- */
if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', router);
else router();

/* ---------- expose helpers ---------- */
window.__hosted_clear = function(){ try{ sessionStorage.removeItem(KEY_AUTH); sessionStorage.removeItem(KEY_PROFILE); }catch(e){}; profile=null; setMain('<div class="small">Cleared.</div>'); };
window.__hosted_process = processStartPayload;

</script>
</body>
</html>